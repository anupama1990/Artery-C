//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/linklayer/ieee80211/mac/Ieee80211Frame.msg.
//

#ifndef __INET_IEEE80211FRAME_M_H
#define __INET_IEEE80211FRAME_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {


}  // namespace inet


namespace inet {
namespace ieee80211 {

class Ieee80211MacTrailer;
class Ieee80211MacHeader;
class Ieee80211OneAddressHeader;
class Ieee80211AckFrame;
class Ieee80211TwoAddressHeader;
class Ieee80211RtsFrame;
class Ieee80211CtsFrame;
class Ieee80211DataOrMgmtHeader;
class Ieee80211DataHeader;
class Ieee80211MgmtHeader;
class Ieee80211ActionFrame;
class Ieee80211MsduSubframeHeader;
class Ieee80211MpduSubframeHeader;
class Ieee80211AddbaRequest;
class Ieee80211AddbaResponse;
class Ieee80211Delba;
class Ieee80211BlockAckReq;
class Ieee80211BasicBlockAckReq;
class Ieee80211CompressedBlockAckReq;
class Ieee80211MultiTidBlockAckReq;
class Ieee80211BlockAck;
class Ieee80211BasicBlockAck;
class Ieee80211CompressedBlockAck;
class Ieee80211MultiTidBlockAck;

}  // namespace ieee80211
}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/linklayer/common/FcsMode_m.h" // import inet.linklayer.common.FcsMode

#include "inet/linklayer/common/MacAddress_m.h" // import inet.linklayer.common.MacAddress

// cplusplus {{
#include "inet/common/BitVector.h"
#include "inet/linklayer/ieee80211/mac/common/Ieee80211Defs.h"
// }}


namespace inet {


}  // namespace inet


namespace inet {
namespace ieee80211 {

// cplusplus {{
const b LENGTH_RTS = b(160);    //bits
const b LENGTH_CTS = b(112);    //bits
const b LENGTH_ACK = b(112);    //bits
const b LENGTH_MGMT = B(28);    //bits
const b LENGTH_ADDBAREQ = LENGTH_MGMT + B(9); // mgmt length + action body length
const b LENGTH_ADDBARESP = LENGTH_MGMT + B(9); // mgmt length + action body length
const b LENGTH_DELBA = LENGTH_MGMT + B(6); // mgmt length + action body length
const b LENGTH_BASIC_BLOCKACK = B(16 + 2 + (2 + 128) + 4); // header + ba control + ba information + fcs
const b DATAFRAME_HEADER_MINLENGTH = B(2 + 2 + 3 * 6 + 2);    //bits without QoS, without Address4: 2 + 2 + 3*6(addresses) + 2
const b QOSCONTROL_PART_LENGTH = b(2 * 8);    // QoS Control field length (bits)
const short int MAX_NUM_FRAGMENTS = 16;
const b LENGTH_A_MSDU_SUBFRAME_HEADER = B(14); //48 + 48 + 16 bits
const b LENGTH_A_MPDU_SUBFRAME_HEADER = b(4 + 12 + 8 + 8);
// }}

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:56</tt> by opp_msgtool.
 * <pre>
 * //
 * // 802.11 frame type constants (type+subtype), for the "type" field of
 * // Ieee80211FrameControl
 * //
 * enum Ieee80211FrameType
 * {
 *     // management:
 *     ST_ASSOCIATIONREQUEST = 0x00;
 *     ST_ASSOCIATIONRESPONSE = 0x01;
 *     ST_REASSOCIATIONREQUEST = 0x02;
 *     ST_REASSOCIATIONRESPONSE = 0x03;
 *     ST_PROBEREQUEST = 0x04;
 *     ST_PROBERESPONSE = 0x05;
 *     ST_BEACON = 0x08;
 *     ST_ATIM = 0x09;
 *     ST_DISASSOCIATION = 0x0a;
 *     ST_AUTHENTICATION = 0x0b;
 *     ST_DEAUTHENTICATION = 0x0c;
 *     ST_ACTION = 0x0d;
 *     ST_NOACKACTION = 0x0e;
 * 
 *     // control (CFEND/CFEND_CFACK omitted):
 *     ST_PSPOLL = 0x1a;
 *     ST_RTS = 0x1b;
 *     ST_CTS = 0x1c;
 *     ST_ACK = 0x1d;
 *     ST_BLOCKACK_REQ = 0x18;
 *     ST_BLOCKACK = 0x19;
 * 
 *     // data (CFPOLL/CFACK subtypes omitted):
 *     ST_DATA = 0x20;
 *     ST_DATA_WITH_QOS = 0x28;
 *     //Feedback frame for multicast tramsmission
 *     ST_LBMS_REQUEST = 0x30;
 *     ST_LBMS_REPORT = 0x31;
 * }
 * </pre>
 */
enum Ieee80211FrameType {
    ST_ASSOCIATIONREQUEST = 0x00,
    ST_ASSOCIATIONRESPONSE = 0x01,
    ST_REASSOCIATIONREQUEST = 0x02,
    ST_REASSOCIATIONRESPONSE = 0x03,
    ST_PROBEREQUEST = 0x04,
    ST_PROBERESPONSE = 0x05,
    ST_BEACON = 0x08,
    ST_ATIM = 0x09,
    ST_DISASSOCIATION = 0x0a,
    ST_AUTHENTICATION = 0x0b,
    ST_DEAUTHENTICATION = 0x0c,
    ST_ACTION = 0x0d,
    ST_NOACKACTION = 0x0e,
    ST_PSPOLL = 0x1a,
    ST_RTS = 0x1b,
    ST_CTS = 0x1c,
    ST_ACK = 0x1d,
    ST_BLOCKACK_REQ = 0x18,
    ST_BLOCKACK = 0x19,
    ST_DATA = 0x20,
    ST_DATA_WITH_QOS = 0x28,
    ST_LBMS_REQUEST = 0x30,
    ST_LBMS_REPORT = 0x31
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211FrameType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211FrameType& e) { int n; b->unpack(n); e = static_cast<Ieee80211FrameType>(n); }

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:92</tt> by opp_msgtool.
 * <pre>
 * //
 * // Ack policy values for the 802.11 QoS control field
 * //
 * enum AckPolicy
 * {
 *     NORMAL_ACK = 0;
 *     NO_ACK = 1;
 *     NO_EXPLICIT_ACK = 2;
 *     BLOCK_ACK = 3;
 * }
 * </pre>
 */
enum AckPolicy {
    NORMAL_ACK = 0,
    NO_ACK = 1,
    NO_EXPLICIT_ACK = 2,
    BLOCK_ACK = 3
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const AckPolicy& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, AckPolicy& e) { int n; b->unpack(n); e = static_cast<AckPolicy>(n); }

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:100</tt> by opp_msgtool.
 * <pre>
 * class Ieee80211MacTrailer extends FieldsChunk
 * {
 *     chunkLength = B(4);
 *     uint32_t fcs = 0;
 *     FcsMode fcsMode = FCS_MODE_UNDEFINED;
 * }
 * </pre>
 */
class INET_API Ieee80211MacTrailer : public ::inet::FieldsChunk
{
  protected:
    uint32_t fcs = 0;
    ::inet::FcsMode fcsMode = FCS_MODE_UNDEFINED;

  private:
    void copy(const Ieee80211MacTrailer& other);

  protected:
    bool operator==(const Ieee80211MacTrailer&) = delete;

  public:
    Ieee80211MacTrailer();
    Ieee80211MacTrailer(const Ieee80211MacTrailer& other);
    virtual ~Ieee80211MacTrailer();
    Ieee80211MacTrailer& operator=(const Ieee80211MacTrailer& other);
    virtual Ieee80211MacTrailer *dup() const override {return new Ieee80211MacTrailer(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint32_t getFcs() const;
    virtual void setFcs(uint32_t fcs);

    virtual ::inet::FcsMode getFcsMode() const;
    virtual void setFcsMode(::inet::FcsMode fcsMode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MacTrailer& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MacTrailer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:115</tt> by opp_msgtool.
 * <pre>
 * //
 * // The common part of 802.11 frames.
 * //
 * // NOTE:
 * // FCS value is not explicitly modeled, but it is included in the length.
 * // Frame control format fields not supported by this model are omitted:
 * // MoreFlag, PowerMgmt, MoreData, WEP, Order.
 * //
 * class Ieee80211MacHeader extends FieldsChunk
 * {
 *     chunkLength = LENGTH_ACK - B(4);
 *     Ieee80211FrameType type; // type and subtype
 *     bool toDS;
 *     bool fromDS;
 *     bool moreFragments;
 *     bool retry;
 *     bool powerMgmt = false; // unused
 *     bool moreData = false; // unused
 *     bool protectedFrame = false; // unused
 *     bool order = false; // unused
 *     simtime_t durationField = -1; // "duration" in the Duration/ID field (-1=no duration)
 *     short AID = -1;          // "id" (Association ID) in the Duration/ID field (-1=no ID)
 *     MacAddress receiverAddress; // aka address1 (RA)
 *     simtime_t MACArrive;    // FIXME remove it, technical data, used inside of MAC module
 * }
 * </pre>
 */
class INET_API Ieee80211MacHeader : public ::inet::FieldsChunk
{
  protected:
    Ieee80211FrameType type = static_cast<inet::ieee80211::Ieee80211FrameType>(-1);
    bool toDS = false;
    bool fromDS = false;
    bool moreFragments = false;
    bool retry = false;
    bool powerMgmt = false;
    bool moreData = false;
    bool protectedFrame = false;
    bool order = false;
    ::omnetpp::simtime_t durationField = -1;
    short AID = -1;
    ::inet::MacAddress receiverAddress;
    ::omnetpp::simtime_t MACArrive = SIMTIME_ZERO;

  private:
    void copy(const Ieee80211MacHeader& other);

  protected:
    bool operator==(const Ieee80211MacHeader&) = delete;

  public:
    Ieee80211MacHeader();
    Ieee80211MacHeader(const Ieee80211MacHeader& other);
    virtual ~Ieee80211MacHeader();
    Ieee80211MacHeader& operator=(const Ieee80211MacHeader& other);
    virtual Ieee80211MacHeader *dup() const override {return new Ieee80211MacHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual Ieee80211FrameType getType() const;
    virtual void setType(Ieee80211FrameType type);

    virtual bool getToDS() const;
    virtual void setToDS(bool toDS);

    virtual bool getFromDS() const;
    virtual void setFromDS(bool fromDS);

    virtual bool getMoreFragments() const;
    virtual void setMoreFragments(bool moreFragments);

    virtual bool getRetry() const;
    virtual void setRetry(bool retry);

    virtual bool getPowerMgmt() const;
    virtual void setPowerMgmt(bool powerMgmt);

    virtual bool getMoreData() const;
    virtual void setMoreData(bool moreData);

    virtual bool getProtectedFrame() const;
    virtual void setProtectedFrame(bool protectedFrame);

    virtual bool getOrder() const;
    virtual void setOrder(bool order);

    virtual ::omnetpp::simtime_t getDurationField() const;
    virtual void setDurationField(::omnetpp::simtime_t durationField);

    virtual short getAID() const;
    virtual void setAID(short AID);

    virtual const ::inet::MacAddress& getReceiverAddress() const;
    virtual ::inet::MacAddress& getReceiverAddressForUpdate() { handleChange();return const_cast<::inet::MacAddress&>(const_cast<Ieee80211MacHeader*>(this)->getReceiverAddress());}
    virtual void setReceiverAddress(const ::inet::MacAddress& receiverAddress);

    virtual ::omnetpp::simtime_t getMACArrive() const;
    virtual void setMACArrive(::omnetpp::simtime_t MACArrive);


    virtual uint8_t getProtocolVersion() const { return ((getType() & 0b11000000) >> 6); }
    virtual uint8_t getFrameType() const { return ((getType() & 0b00110000) >> 4); }
    virtual uint8_t getSubType() const { return (getType() & 0b00001111); }
    virtual void setType(uint8_t protocolVersion, uint8_t frameType, uint8_t subType) {
        setType(static_cast<inet::ieee80211::Ieee80211FrameType>((protocolVersion << 6) | (frameType << 4) | subType));
    }
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MacHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MacHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:145</tt> by opp_msgtool.
 * <pre>
 * //
 * // Format of a 802.11 frame with address1 present, like ACK and CTS
 * //
 * class Ieee80211OneAddressHeader extends Ieee80211MacHeader
 * {
 * }
 * </pre>
 */
class INET_API Ieee80211OneAddressHeader : public ::inet::ieee80211::Ieee80211MacHeader
{
  protected:

  private:
    void copy(const Ieee80211OneAddressHeader& other);

  protected:
    bool operator==(const Ieee80211OneAddressHeader&) = delete;

  public:
    Ieee80211OneAddressHeader();
    Ieee80211OneAddressHeader(const Ieee80211OneAddressHeader& other);
    virtual ~Ieee80211OneAddressHeader();
    Ieee80211OneAddressHeader& operator=(const Ieee80211OneAddressHeader& other);
    virtual Ieee80211OneAddressHeader *dup() const override {return new Ieee80211OneAddressHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211OneAddressHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211OneAddressHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:152</tt> by opp_msgtool.
 * <pre>
 * //
 * // Format of the 802.11 ACK frame
 * //
 * class Ieee80211AckFrame extends Ieee80211OneAddressHeader
 * {
 *     chunkLength = LENGTH_ACK - B(4);
 *     type = ST_ACK;
 * }
 * </pre>
 */
class INET_API Ieee80211AckFrame : public ::inet::ieee80211::Ieee80211OneAddressHeader
{
  protected:

  private:
    void copy(const Ieee80211AckFrame& other);

  protected:
    bool operator==(const Ieee80211AckFrame&) = delete;

  public:
    Ieee80211AckFrame();
    Ieee80211AckFrame(const Ieee80211AckFrame& other);
    virtual ~Ieee80211AckFrame();
    Ieee80211AckFrame& operator=(const Ieee80211AckFrame& other);
    virtual Ieee80211AckFrame *dup() const override {return new Ieee80211AckFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AckFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AckFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:161</tt> by opp_msgtool.
 * <pre>
 * //
 * // Format of a 802.11 frame with address1 and address2 present
 * //
 * class Ieee80211TwoAddressHeader extends Ieee80211OneAddressHeader
 * {
 *     chunkLength = LENGTH_RTS - B(4);
 *     MacAddress transmitterAddress; // aka address2 (TA)
 * }
 * </pre>
 */
class INET_API Ieee80211TwoAddressHeader : public ::inet::ieee80211::Ieee80211OneAddressHeader
{
  protected:
    ::inet::MacAddress transmitterAddress;

  private:
    void copy(const Ieee80211TwoAddressHeader& other);

  protected:
    bool operator==(const Ieee80211TwoAddressHeader&) = delete;

  public:
    Ieee80211TwoAddressHeader();
    Ieee80211TwoAddressHeader(const Ieee80211TwoAddressHeader& other);
    virtual ~Ieee80211TwoAddressHeader();
    Ieee80211TwoAddressHeader& operator=(const Ieee80211TwoAddressHeader& other);
    virtual Ieee80211TwoAddressHeader *dup() const override {return new Ieee80211TwoAddressHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::MacAddress& getTransmitterAddress() const;
    virtual ::inet::MacAddress& getTransmitterAddressForUpdate() { handleChange();return const_cast<::inet::MacAddress&>(const_cast<Ieee80211TwoAddressHeader*>(this)->getTransmitterAddress());}
    virtual void setTransmitterAddress(const ::inet::MacAddress& transmitterAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211TwoAddressHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211TwoAddressHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:170</tt> by opp_msgtool.
 * <pre>
 * //
 * // Format of the 802.11 RTS frame
 * //
 * class Ieee80211RtsFrame extends Ieee80211TwoAddressHeader
 * {
 *     chunkLength = LENGTH_RTS - B(4);
 *     type = ST_RTS;
 * }
 * </pre>
 */
class INET_API Ieee80211RtsFrame : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:

  private:
    void copy(const Ieee80211RtsFrame& other);

  protected:
    bool operator==(const Ieee80211RtsFrame&) = delete;

  public:
    Ieee80211RtsFrame();
    Ieee80211RtsFrame(const Ieee80211RtsFrame& other);
    virtual ~Ieee80211RtsFrame();
    Ieee80211RtsFrame& operator=(const Ieee80211RtsFrame& other);
    virtual Ieee80211RtsFrame *dup() const override {return new Ieee80211RtsFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211RtsFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211RtsFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:179</tt> by opp_msgtool.
 * <pre>
 * //
 * // Format of the 802.11 CTS frame
 * //
 * class Ieee80211CtsFrame extends Ieee80211OneAddressHeader
 * {
 *     chunkLength = LENGTH_CTS - B(4);
 *     type = ST_CTS;
 * }
 * </pre>
 */
class INET_API Ieee80211CtsFrame : public ::inet::ieee80211::Ieee80211OneAddressHeader
{
  protected:

  private:
    void copy(const Ieee80211CtsFrame& other);

  protected:
    bool operator==(const Ieee80211CtsFrame&) = delete;

  public:
    Ieee80211CtsFrame();
    Ieee80211CtsFrame(const Ieee80211CtsFrame& other);
    virtual ~Ieee80211CtsFrame();
    Ieee80211CtsFrame& operator=(const Ieee80211CtsFrame& other);
    virtual Ieee80211CtsFrame *dup() const override {return new Ieee80211CtsFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CtsFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CtsFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:188</tt> by opp_msgtool.
 * <pre>
 * //
 * // Common base class for 802.11 data and management frames
 * //
 * class Ieee80211DataOrMgmtHeader extends Ieee80211TwoAddressHeader
 * {
 *     chunkLength = LENGTH_MGMT - B(4);
 *     MacAddress address3;
 *     short fragmentNumber;
 *     SequenceNumberCyclic sequenceNumber;
 * }
 * </pre>
 */
class INET_API Ieee80211DataOrMgmtHeader : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:
    ::inet::MacAddress address3;
    short fragmentNumber = 0;
    SequenceNumberCyclic sequenceNumber;

  private:
    void copy(const Ieee80211DataOrMgmtHeader& other);

  protected:
    bool operator==(const Ieee80211DataOrMgmtHeader&) = delete;

  public:
    Ieee80211DataOrMgmtHeader();
    Ieee80211DataOrMgmtHeader(const Ieee80211DataOrMgmtHeader& other);
    virtual ~Ieee80211DataOrMgmtHeader();
    Ieee80211DataOrMgmtHeader& operator=(const Ieee80211DataOrMgmtHeader& other);
    virtual Ieee80211DataOrMgmtHeader *dup() const override {return new Ieee80211DataOrMgmtHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::MacAddress& getAddress3() const;
    virtual ::inet::MacAddress& getAddress3ForUpdate() { handleChange();return const_cast<::inet::MacAddress&>(const_cast<Ieee80211DataOrMgmtHeader*>(this)->getAddress3());}
    virtual void setAddress3(const ::inet::MacAddress& address3);

    virtual short getFragmentNumber() const;
    virtual void setFragmentNumber(short fragmentNumber);

    virtual const SequenceNumberCyclic& getSequenceNumber() const;
    virtual SequenceNumberCyclic& getSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumberCyclic&>(const_cast<Ieee80211DataOrMgmtHeader*>(this)->getSequenceNumber());}
    virtual void setSequenceNumber(const SequenceNumberCyclic& sequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataOrMgmtHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataOrMgmtHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:199</tt> by opp_msgtool.
 * <pre>
 * //
 * // Format of the 802.11 data frame
 * //
 * class Ieee80211DataHeader extends Ieee80211DataOrMgmtHeader
 * {
 *     //  The presence of the Address 4 field is determined by the setting of the To DS and From DS subfields of
 *     //  the Frame Control field (see below). The QoS Control field is present when the QoS subfield of the Subtype
 *     //  field is set to 1 (8.3.2.1 Data frame format)
 *     //  FIXME chunkLength is not a constant value DATAFRAME_HEADER_MINLENGTH (24 bytes).
 *     //  For example, with Address 4 and without QoS the correct length is 30 bytes.
 *     //  Without Address 4 and QoS the correct value is indeed 24 bytes.
 *     //  With Address 4 and QoS the correct value is indeed 32 bytes.
 *     chunkLength = DATAFRAME_HEADER_MINLENGTH;
 *     type = ST_DATA;         // or ST_DATA_WITH_QOS
 *     MacAddress address4;    // optional field, exists when toDS and fromDS are true
 *     AckPolicy ackPolicy = NORMAL_ACK;
 *     uint8_t tid;              // optional field, exists when type == ST_DATA_WITH_QOS
 *     bool aMsduPresent = false; // 8.2.4.5.9 A-MSDU Present subfield
 * }
 * 
 * //TODO this can be introduced when the SNAP header
 * //class Ieee80211QoSDataHeader extends Ieee80211DataHeader
 * //{
 * //    type = ST_DATA_WITH_QOS;
 * //    chunkLength = DATAFRAME_HEADER_MINLENGTH + QOSCONTROL_PART_LENGTH;
 * //    AckPolicy ackPolicy = NORMAL_ACK; //FIXME in real life this is part of the optional qos field above...
 * //    uint8_t tid;
 * //    // TODO other QoS control field parts
 * //}
 * </pre>
 */
class INET_API Ieee80211DataHeader : public ::inet::ieee80211::Ieee80211DataOrMgmtHeader
{
  protected:
    ::inet::MacAddress address4;
    AckPolicy ackPolicy = NORMAL_ACK;
    uint8_t tid = 0;
    bool aMsduPresent = false;

  private:
    void copy(const Ieee80211DataHeader& other);

  protected:
    bool operator==(const Ieee80211DataHeader&) = delete;

  public:
    Ieee80211DataHeader();
    Ieee80211DataHeader(const Ieee80211DataHeader& other);
    virtual ~Ieee80211DataHeader();
    Ieee80211DataHeader& operator=(const Ieee80211DataHeader& other);
    virtual Ieee80211DataHeader *dup() const override {return new Ieee80211DataHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::MacAddress& getAddress4() const;
    virtual ::inet::MacAddress& getAddress4ForUpdate() { handleChange();return const_cast<::inet::MacAddress&>(const_cast<Ieee80211DataHeader*>(this)->getAddress4());}
    virtual void setAddress4(const ::inet::MacAddress& address4);

    virtual AckPolicy getAckPolicy() const;
    virtual void setAckPolicy(AckPolicy ackPolicy);

    virtual uint8_t getTid() const;
    virtual void setTid(uint8_t tid);

    virtual bool getAMsduPresent() const;
    virtual void setAMsduPresent(bool aMsduPresent);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:229</tt> by opp_msgtool.
 * <pre>
 * //
 * // Base class for 802.11 management frames (subclasses will add frame body contents)
 * //
 * class Ieee80211MgmtHeader extends Ieee80211DataOrMgmtHeader
 * {
 * }
 * </pre>
 */
class INET_API Ieee80211MgmtHeader : public ::inet::ieee80211::Ieee80211DataOrMgmtHeader
{
  protected:

  private:
    void copy(const Ieee80211MgmtHeader& other);

  protected:
    bool operator==(const Ieee80211MgmtHeader&) = delete;

  public:
    Ieee80211MgmtHeader();
    Ieee80211MgmtHeader(const Ieee80211MgmtHeader& other);
    virtual ~Ieee80211MgmtHeader();
    Ieee80211MgmtHeader& operator=(const Ieee80211MgmtHeader& other);
    virtual Ieee80211MgmtHeader *dup() const override {return new Ieee80211MgmtHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MgmtHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MgmtHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:234</tt> by opp_msgtool.
 * <pre>
 * // 8.3.3.13 Action frame format -- mgmt frame with subtype action
 * class Ieee80211ActionFrame extends Ieee80211MgmtHeader
 * {
 *     type = ST_ACTION;
 *     short category;
 *     uint8_t blockAckAction;
 *     // TODO subclasses will add action subfield contents
 *     //WirelessNetworkManagementAction action; // action TODO remove it
 * }
 * </pre>
 */
class INET_API Ieee80211ActionFrame : public ::inet::ieee80211::Ieee80211MgmtHeader
{
  protected:
    short category = 0;
    uint8_t blockAckAction = 0;

  private:
    void copy(const Ieee80211ActionFrame& other);

  protected:
    bool operator==(const Ieee80211ActionFrame&) = delete;

  public:
    Ieee80211ActionFrame();
    Ieee80211ActionFrame(const Ieee80211ActionFrame& other);
    virtual ~Ieee80211ActionFrame();
    Ieee80211ActionFrame& operator=(const Ieee80211ActionFrame& other);
    virtual Ieee80211ActionFrame *dup() const override {return new Ieee80211ActionFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual short getCategory() const;
    virtual void setCategory(short category);

    virtual uint8_t getBlockAckAction() const;
    virtual void setBlockAckAction(uint8_t blockAckAction);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211ActionFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:243</tt> by opp_msgtool.
 * <pre>
 * class Ieee80211MsduSubframeHeader extends FieldsChunk
 * {
 *     chunkLength = LENGTH_A_MSDU_SUBFRAME_HEADER;
 *     MacAddress sa; // source addr.
 *     MacAddress da; // destination addr.
 *     int length;
 * }
 * </pre>
 */
class INET_API Ieee80211MsduSubframeHeader : public ::inet::FieldsChunk
{
  protected:
    ::inet::MacAddress sa;
    ::inet::MacAddress da;
    int length = 0;

  private:
    void copy(const Ieee80211MsduSubframeHeader& other);

  protected:
    bool operator==(const Ieee80211MsduSubframeHeader&) = delete;

  public:
    Ieee80211MsduSubframeHeader();
    Ieee80211MsduSubframeHeader(const Ieee80211MsduSubframeHeader& other);
    virtual ~Ieee80211MsduSubframeHeader();
    Ieee80211MsduSubframeHeader& operator=(const Ieee80211MsduSubframeHeader& other);
    virtual Ieee80211MsduSubframeHeader *dup() const override {return new Ieee80211MsduSubframeHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::MacAddress& getSa() const;
    virtual ::inet::MacAddress& getSaForUpdate() { handleChange();return const_cast<::inet::MacAddress&>(const_cast<Ieee80211MsduSubframeHeader*>(this)->getSa());}
    virtual void setSa(const ::inet::MacAddress& sa);

    virtual const ::inet::MacAddress& getDa() const;
    virtual ::inet::MacAddress& getDaForUpdate() { handleChange();return const_cast<::inet::MacAddress&>(const_cast<Ieee80211MsduSubframeHeader*>(this)->getDa());}
    virtual void setDa(const ::inet::MacAddress& da);

    virtual int getLength() const;
    virtual void setLength(int length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MsduSubframeHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MsduSubframeHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:251</tt> by opp_msgtool.
 * <pre>
 * class Ieee80211MpduSubframeHeader extends FieldsChunk
 * {
 *     chunkLength = LENGTH_A_MPDU_SUBFRAME_HEADER;
 *     int length;
 * }
 * </pre>
 */
class INET_API Ieee80211MpduSubframeHeader : public ::inet::FieldsChunk
{
  protected:
    int length = 0;

  private:
    void copy(const Ieee80211MpduSubframeHeader& other);

  protected:
    bool operator==(const Ieee80211MpduSubframeHeader&) = delete;

  public:
    Ieee80211MpduSubframeHeader();
    Ieee80211MpduSubframeHeader(const Ieee80211MpduSubframeHeader& other);
    virtual ~Ieee80211MpduSubframeHeader();
    Ieee80211MpduSubframeHeader& operator=(const Ieee80211MpduSubframeHeader& other);
    virtual Ieee80211MpduSubframeHeader *dup() const override {return new Ieee80211MpduSubframeHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getLength() const;
    virtual void setLength(int length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MpduSubframeHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MpduSubframeHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:260</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.5.5.2 ADDBA Request frame format
 * //
 * class Ieee80211AddbaRequest extends Ieee80211ActionFrame
 * {
 *     chunkLength = LENGTH_ADDBAREQ - B(4);
 *     category = 3; // category field set to 3 (representing Block Ack). (1 byte)
 *     blockAckAction = 0; // Block Ack Action field is set to 0 (representing ADDBA request). (1 byte)
 *     uint8_t dialogToken = 1; // Dialog Token field is set to a nonzero value chosen by the STA. (1 byte)
 * 
 *     // Block Ack Parameter Set field (2 bytes)
 *     bool aMsduSupported; // The A-MSDU Supported subfield determines whether an A-MSDU may be carried in a QoS data MPDU sent under this Block Ack agreement. (1 bit)
 *     bool blockAckPolicy; // The Block Ack Policy subfield is set to 1 for immediate Block Ack and 0 for delayed Block Ack. (1 bit)
 *     uint8_t tid; // The TID subfield contains the value of the TC or TS for which the BlockAck is being requested. (4 bits)
 *     uint16_t bufferSize; // The Buffer Size subfield indicates the number of buffers available for this particular TID. (10 bits)
 * 
 *     // Block Ack Timeout Value field (2 bytes)
 *     // The Block Ack Timeout Value field contains the duration, in TUs, after which the Block Ack setup is
 *     // terminated, if there are no frame exchanges (see 10.5.4) within this duration using this Block Ack
 *     // agreement. A value of 0 disables the timeout.
 *     simtime_t blockAckTimeoutValue;
 * 
 *     // Block Ack Starting Sequence Control (2 bytes)
 *     // The Starting Sequence Number subfield of the Block Ack Starting Sequence Control subfield contains the sequence number of the first MSDU for which this Basic
 *     // BlockAckReq frame is sent. The Fragment Number subfield is set to 0.
 *     uint8_t _fragmentNumber = 0; // FIXME DataOrMgmtFreme has a fragmentNumber (4 bits)
 *     SequenceNumberCyclic startingSequenceNumber; // the sequence number of the first MSDU (12 bits)
 * }
 * </pre>
 */
class INET_API Ieee80211AddbaRequest : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    uint8_t dialogToken = 1;
    bool aMsduSupported = false;
    bool blockAckPolicy = false;
    uint8_t tid = 0;
    uint16_t bufferSize = 0;
    ::omnetpp::simtime_t blockAckTimeoutValue = SIMTIME_ZERO;
    uint8_t _fragmentNumber = 0;
    SequenceNumberCyclic startingSequenceNumber;

  private:
    void copy(const Ieee80211AddbaRequest& other);

  protected:
    bool operator==(const Ieee80211AddbaRequest&) = delete;

  public:
    Ieee80211AddbaRequest();
    Ieee80211AddbaRequest(const Ieee80211AddbaRequest& other);
    virtual ~Ieee80211AddbaRequest();
    Ieee80211AddbaRequest& operator=(const Ieee80211AddbaRequest& other);
    virtual Ieee80211AddbaRequest *dup() const override {return new Ieee80211AddbaRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getDialogToken() const;
    virtual void setDialogToken(uint8_t dialogToken);

    virtual bool getAMsduSupported() const;
    virtual void setAMsduSupported(bool aMsduSupported);

    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);

    virtual uint8_t getTid() const;
    virtual void setTid(uint8_t tid);

    virtual uint16_t getBufferSize() const;
    virtual void setBufferSize(uint16_t bufferSize);

    virtual ::omnetpp::simtime_t getBlockAckTimeoutValue() const;
    virtual void setBlockAckTimeoutValue(::omnetpp::simtime_t blockAckTimeoutValue);

    virtual uint8_t get_fragmentNumber() const;
    virtual void set_fragmentNumber(uint8_t _fragmentNumber);

    virtual const SequenceNumberCyclic& getStartingSequenceNumber() const;
    virtual SequenceNumberCyclic& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumberCyclic&>(const_cast<Ieee80211AddbaRequest*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumberCyclic& startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AddbaRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AddbaRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:289</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.5.5.3 ADDBA Response frame format
 * //
 * class Ieee80211AddbaResponse extends Ieee80211ActionFrame
 * {
 *     chunkLength = LENGTH_ADDBARESP - B(4);
 *     category = 3; // Category field is set to 3 (representing Block Ack). (1 byte)
 *     blockAckAction = 1; // Block Ack Action field is set to 1 (representing ADDBA response). (1 byte)
 *     uint8_t dialogToken = 1; // The Dialog Token field value is copied from the corresponding received ADDBA Request frame. (1 byte)
 *     uint16_t statusCode; // The Status Code field is used in a response management frame to indicate the success or failure of a requested operation. (2 bytes)
 * 
 *     // Block Ack Parameter Set field (2 bytes)
 *     bool aMsduSupported; // The A-MSDU Supported subfield determines whether an A-MSDU may be carried in a QoS data MPDU sent under this Block Ack agreement. (1 bit)
 *     bool blockAckPolicy; // The Block Ack Policy subfield is set to 1 for immediate Block Ack and 0 for delayed Block Ack. (1 bit)
 *     uint8_t tid; // The TID subfield contains the value of the TC or TS for which the BlockAck is being requested. (4 bits)
 *     uint16_t bufferSize; // The Buffer Size subfield indicates the number of buffers available for this particular TID. (10 bits)
 * 
 *     // Block Ack Timeout Value field (2 bytes)
 *     // The Block Ack Timeout Value field contains the duration, in TUs, after which the Block Ack setup is
 *     // terminated, if there are no frame exchanges (see 10.5.4) within this duration using this Block Ack
 *     // agreement. A value of 0 disables the timeout.
 *     simtime_t blockAckTimeoutValue;
 * }
 * </pre>
 */
class INET_API Ieee80211AddbaResponse : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    uint8_t dialogToken = 1;
    uint16_t statusCode = 0;
    bool aMsduSupported = false;
    bool blockAckPolicy = false;
    uint8_t tid = 0;
    uint16_t bufferSize = 0;
    ::omnetpp::simtime_t blockAckTimeoutValue = SIMTIME_ZERO;

  private:
    void copy(const Ieee80211AddbaResponse& other);

  protected:
    bool operator==(const Ieee80211AddbaResponse&) = delete;

  public:
    Ieee80211AddbaResponse();
    Ieee80211AddbaResponse(const Ieee80211AddbaResponse& other);
    virtual ~Ieee80211AddbaResponse();
    Ieee80211AddbaResponse& operator=(const Ieee80211AddbaResponse& other);
    virtual Ieee80211AddbaResponse *dup() const override {return new Ieee80211AddbaResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getDialogToken() const;
    virtual void setDialogToken(uint8_t dialogToken);

    virtual uint16_t getStatusCode() const;
    virtual void setStatusCode(uint16_t statusCode);

    virtual bool getAMsduSupported() const;
    virtual void setAMsduSupported(bool aMsduSupported);

    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);

    virtual uint8_t getTid() const;
    virtual void setTid(uint8_t tid);

    virtual uint16_t getBufferSize() const;
    virtual void setBufferSize(uint16_t bufferSize);

    virtual ::omnetpp::simtime_t getBlockAckTimeoutValue() const;
    virtual void setBlockAckTimeoutValue(::omnetpp::simtime_t blockAckTimeoutValue);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AddbaResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AddbaResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:313</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.5.5.4 DELBA frame format
 * //
 * class Ieee80211Delba extends Ieee80211ActionFrame
 * {
 *     chunkLength = LENGTH_DELBA;
 *     category = 3; // Category field is set to 3 (representing DELBA). (1 byte)
 *     blockAckAction = 2; // Block Ack Action field is set to 2 (representing DELBA). (1 byte)
 * 
 *     // DELBA Parameter Set (2 bytes)
 *     uint16_t reserved = 0; // Reserved. (11 bits)
 *     bool initiator; // It is set to 1 to indicate the originator and is set to 0 to indicate the recipient.
 *                     // The Initiator subfield indicates if the originator or the recipient of the data is sending this frame. (1 bit)
 *     uint8_t tid; // The TID subfield indicates the TSID or the UP for which the Block Ack has been originally set up. (4 bits)
 * 
 *     // This Reason Code field is used to indicate the reason that an unsolicited notification management frame of
 *     // type Disassociation, Deauthentication, DELTS, DELBA, DLS Teardown, or Mesh Peering Close was
 *     // generated. (2 bytes)
 *     uint16_t reasonCode;
 * }
 * </pre>
 */
class INET_API Ieee80211Delba : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    uint16_t reserved = 0;
    bool initiator = false;
    uint8_t tid = 0;
    uint16_t reasonCode = 0;

  private:
    void copy(const Ieee80211Delba& other);

  protected:
    bool operator==(const Ieee80211Delba&) = delete;

  public:
    Ieee80211Delba();
    Ieee80211Delba(const Ieee80211Delba& other);
    virtual ~Ieee80211Delba();
    Ieee80211Delba& operator=(const Ieee80211Delba& other);
    virtual Ieee80211Delba *dup() const override {return new Ieee80211Delba(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint16_t getReserved() const;
    virtual void setReserved(uint16_t reserved);

    virtual bool getInitiator() const;
    virtual void setInitiator(bool initiator);

    virtual uint8_t getTid() const;
    virtual void setTid(uint8_t tid);

    virtual uint16_t getReasonCode() const;
    virtual void setReasonCode(uint16_t reasonCode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211Delba& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211Delba& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:334</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.3.1.8 BlockAckReq frame format
 * //
 * class Ieee80211BlockAckReq extends Ieee80211TwoAddressHeader
 * {
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 * 
 *     bool multiTid;
 *     bool compressedBitmap;
 *     bool barAckPolicy; // 0-Normal Acknowledgment, 1-No Acknowledgment.
 *     uint16_t reserved = 0;
 * }
 * </pre>
 */
class INET_API Ieee80211BlockAckReq : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:
    bool multiTid = false;
    bool compressedBitmap = false;
    bool barAckPolicy = false;
    uint16_t reserved = 0;

  private:
    void copy(const Ieee80211BlockAckReq& other);

  protected:
    bool operator==(const Ieee80211BlockAckReq&) = delete;

  public:
    Ieee80211BlockAckReq();
    Ieee80211BlockAckReq(const Ieee80211BlockAckReq& other);
    virtual ~Ieee80211BlockAckReq();
    Ieee80211BlockAckReq& operator=(const Ieee80211BlockAckReq& other);
    virtual Ieee80211BlockAckReq *dup() const override {return new Ieee80211BlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getMultiTid() const;
    virtual void setMultiTid(bool multiTid);

    virtual bool getCompressedBitmap() const;
    virtual void setCompressedBitmap(bool compressedBitmap);

    virtual bool getBarAckPolicy() const;
    virtual void setBarAckPolicy(bool barAckPolicy);

    virtual uint16_t getReserved() const;
    virtual void setReserved(uint16_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:346</tt> by opp_msgtool.
 * <pre>
 * class Ieee80211BasicBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     chunkLength = B(38);
 * 
 *     int tidInfo; //  The TID_INFO subfield of the BAR Control field of the Basic BlockAckReq frame contains the TID for which a Basic BlockAck frame is requested.
 * 
 *     // The BAR Information field of the Basic BlockAckReq frame contains the Block Ack Starting Sequence
 *     // Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block Ack
 *     // Starting Sequence Control subfield contains the sequence number of the first MSDU for which this Basic
 *     // BlockAckReq frame is sent. The Fragment Number subfield is set to 0.
 *     int fragmentNumber = 0;
 *     SequenceNumberCyclic startingSequenceNumber;
 * 
 *     multiTid = 0;
 *     compressedBitmap = 0;
 * }
 * </pre>
 */
class INET_API Ieee80211BasicBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:
    int tidInfo = 0;
    int fragmentNumber = 0;
    SequenceNumberCyclic startingSequenceNumber;

  private:
    void copy(const Ieee80211BasicBlockAckReq& other);

  protected:
    bool operator==(const Ieee80211BasicBlockAckReq&) = delete;

  public:
    Ieee80211BasicBlockAckReq();
    Ieee80211BasicBlockAckReq(const Ieee80211BasicBlockAckReq& other);
    virtual ~Ieee80211BasicBlockAckReq();
    Ieee80211BasicBlockAckReq& operator=(const Ieee80211BasicBlockAckReq& other);
    virtual Ieee80211BasicBlockAckReq *dup() const override {return new Ieee80211BasicBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);

    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);

    virtual const SequenceNumberCyclic& getStartingSequenceNumber() const;
    virtual SequenceNumberCyclic& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumberCyclic&>(const_cast<Ieee80211BasicBlockAckReq*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumberCyclic& startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BasicBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BasicBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:363</tt> by opp_msgtool.
 * <pre>
 * class Ieee80211CompressedBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     chunkLength = B(38);
 * 
 *     int tidInfo; // The TID_INFO subfield of the BAR Control field of the Compressed BlockAckReq frame contains the TID for which a BlockAck frame is requested.
 *     // The BAR Information field of the Compressed BlockAckReq frame contains the Block Ack Starting
 *     // Sequence Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block
 *     // Ack Starting Sequence Control subfield contains the sequence number of the first MSDU or A-MSDU for
 *     // which this BlockAckReq frame is sent. The Fragment Number subfield of the Block Ack Starting Sequence
 *     // Control subfield is set to 0.
 * 
 *     int fragmentNumber = 0;
 *     SequenceNumberCyclic startingSequenceNumber;
 * 
 *     multiTid = 0;
 *     compressedBitmap = 1;
 * }
 * </pre>
 */
class INET_API Ieee80211CompressedBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:
    int tidInfo = 0;
    int fragmentNumber = 0;
    SequenceNumberCyclic startingSequenceNumber;

  private:
    void copy(const Ieee80211CompressedBlockAckReq& other);

  protected:
    bool operator==(const Ieee80211CompressedBlockAckReq&) = delete;

  public:
    Ieee80211CompressedBlockAckReq();
    Ieee80211CompressedBlockAckReq(const Ieee80211CompressedBlockAckReq& other);
    virtual ~Ieee80211CompressedBlockAckReq();
    Ieee80211CompressedBlockAckReq& operator=(const Ieee80211CompressedBlockAckReq& other);
    virtual Ieee80211CompressedBlockAckReq *dup() const override {return new Ieee80211CompressedBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);

    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);

    virtual const SequenceNumberCyclic& getStartingSequenceNumber() const;
    virtual SequenceNumberCyclic& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumberCyclic&>(const_cast<Ieee80211CompressedBlockAckReq*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumberCyclic& startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CompressedBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CompressedBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:381</tt> by opp_msgtool.
 * <pre>
 * class Ieee80211MultiTidBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     multiTid = 1;
 *     compressedBitmap = 1;
 * 
 *     // TODO unimplemented
 * }
 * </pre>
 */
class INET_API Ieee80211MultiTidBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:

  private:
    void copy(const Ieee80211MultiTidBlockAckReq& other);

  protected:
    bool operator==(const Ieee80211MultiTidBlockAckReq&) = delete;

  public:
    Ieee80211MultiTidBlockAckReq();
    Ieee80211MultiTidBlockAckReq(const Ieee80211MultiTidBlockAckReq& other);
    virtual ~Ieee80211MultiTidBlockAckReq();
    Ieee80211MultiTidBlockAckReq& operator=(const Ieee80211MultiTidBlockAckReq& other);
    virtual Ieee80211MultiTidBlockAckReq *dup() const override {return new Ieee80211MultiTidBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MultiTidBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MultiTidBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:399</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.3.1.9 BlockAck frame format -- 410p.
 * //
 * class Ieee80211BlockAck extends Ieee80211TwoAddressHeader
 * {
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK;
 * 
 *     // BA Control
 *     bool blockAckPolicy; // Table 8-17—BA Ack Policy subfield: 0-Normal Acknowledgment, 1-No Acknowledgment.
 * 
 *     // Table 8-18—BlockAck frame variant encoding
 *     bool multiTid;
 *     bool compressedBitmap;
 *     uint16_t reserved = 0;
 * }
 * </pre>
 */
class INET_API Ieee80211BlockAck : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:
    bool blockAckPolicy = false;
    bool multiTid = false;
    bool compressedBitmap = false;
    uint16_t reserved = 0;

  private:
    void copy(const Ieee80211BlockAck& other);

  protected:
    bool operator==(const Ieee80211BlockAck&) = delete;

  public:
    Ieee80211BlockAck();
    Ieee80211BlockAck(const Ieee80211BlockAck& other);
    virtual ~Ieee80211BlockAck();
    Ieee80211BlockAck& operator=(const Ieee80211BlockAck& other);
    virtual Ieee80211BlockAck *dup() const override {return new Ieee80211BlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);

    virtual bool getMultiTid() const;
    virtual void setMultiTid(bool multiTid);

    virtual bool getCompressedBitmap() const;
    virtual void setCompressedBitmap(bool compressedBitmap);

    virtual uint16_t getReserved() const;
    virtual void setReserved(uint16_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:417</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.3.1.9.2 Basic BlockAck variant -- 411p.
 * //
 * class Ieee80211BasicBlockAck extends Ieee80211BlockAck
 * {
 *     chunkLength = LENGTH_BASIC_BLOCKACK - B(4);
 *     multiTid = 0;
 *     compressedBitmap = 0;
 * 
 *     // The BA Information field of the Basic BlockAck frame comprises the Block Ack Starting Sequence Control
 *     // subfield and the Block Ack Bitmap subfield, as shown in Figure 8-26.
 * 
 *     int fragmentNumber = 0; // ??
 *     SequenceNumberCyclic startingSequenceNumber;
 *     // The Block Ack Bitmap subfield is 128 octets in length and is used to indicate the received status of up to
 *     // 64 MSDUs. Bit position n of the Block Ack bitmap, if equal to 1, acknowledges receipt of an MPDU with an
 *     // MPDU sequence control value equal to (Block Ack Starting Sequence Control + n). Bit position n of the
 *     // Block Ack bitmap, if equal to 0, indicates that an MPDU with MPDU sequence control value equal to
 *     // (Block Ack Starting Sequence Control + n) has not been received. Each of the MPDU Sequence Control
 *     // field and Block Ack Starting Sequence Control subfield values are treated as a 16-bit unsigned integer. For
 *     // unused fragment numbers of an MSDU, the corresponding bits in the bitmap are set to 0.
 *     BitVector blockAckBitmap[64]; // 64 * 16 bitmatrix
 * 
 *     // The TID_INFO subfield of the BA Control field of the Basic BlockAck frame contains the TID for which
 *     // this BlockAck frame is sent.
 *     int tidInfo;
 * }
 * </pre>
 */
class INET_API Ieee80211BasicBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:
    int fragmentNumber = 0;
    SequenceNumberCyclic startingSequenceNumber;
    ::inet::BitVector blockAckBitmap[64];
    int tidInfo = 0;

  private:
    void copy(const Ieee80211BasicBlockAck& other);

  protected:
    bool operator==(const Ieee80211BasicBlockAck&) = delete;

  public:
    Ieee80211BasicBlockAck();
    Ieee80211BasicBlockAck(const Ieee80211BasicBlockAck& other);
    virtual ~Ieee80211BasicBlockAck();
    Ieee80211BasicBlockAck& operator=(const Ieee80211BasicBlockAck& other);
    virtual Ieee80211BasicBlockAck *dup() const override {return new Ieee80211BasicBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);

    virtual const SequenceNumberCyclic& getStartingSequenceNumber() const;
    virtual SequenceNumberCyclic& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumberCyclic&>(const_cast<Ieee80211BasicBlockAck*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumberCyclic& startingSequenceNumber);

    virtual size_t getBlockAckBitmapArraySize() const;
    virtual const ::inet::BitVector& getBlockAckBitmap(size_t k) const;
    virtual ::inet::BitVector& getBlockAckBitmapForUpdate(size_t k) { handleChange();return const_cast<::inet::BitVector&>(const_cast<Ieee80211BasicBlockAck*>(this)->getBlockAckBitmap(k));}
    virtual void setBlockAckBitmap(size_t k, const ::inet::BitVector& blockAckBitmap);

    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BasicBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BasicBlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:445</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.3.1.9.3 Compressed BlockAck variant
 * //
 * class Ieee80211CompressedBlockAck extends Ieee80211BlockAck
 * {
 *     // chunkLength TODO
 *     multiTid = 0;
 *     compressedBitmap = 1;
 * 
 *     // The BA Information field of the Compressed BlockAck frame comprises the Block Ack Starting Sequence
 *     // Control subfield and the Block Ack Bitmap subfield, as shown in Figure 8-27.
 * 
 *     int fragmentNumber = 0;
 *     SequenceNumberCyclic startingSequenceNumber;
 *     BitVector blockAckBitmap; // 64 bits
 * 
 *     // The TID_INFO subfield of the BA Control field of the Compressed BlockAck frame contains the TID for
 *     // which this BlockAck frame is sent.
 *     int tidInfo;
 * }
 * </pre>
 */
class INET_API Ieee80211CompressedBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:
    int fragmentNumber = 0;
    SequenceNumberCyclic startingSequenceNumber;
    ::inet::BitVector blockAckBitmap;
    int tidInfo = 0;

  private:
    void copy(const Ieee80211CompressedBlockAck& other);

  protected:
    bool operator==(const Ieee80211CompressedBlockAck&) = delete;

  public:
    Ieee80211CompressedBlockAck();
    Ieee80211CompressedBlockAck(const Ieee80211CompressedBlockAck& other);
    virtual ~Ieee80211CompressedBlockAck();
    Ieee80211CompressedBlockAck& operator=(const Ieee80211CompressedBlockAck& other);
    virtual Ieee80211CompressedBlockAck *dup() const override {return new Ieee80211CompressedBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);

    virtual const SequenceNumberCyclic& getStartingSequenceNumber() const;
    virtual SequenceNumberCyclic& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumberCyclic&>(const_cast<Ieee80211CompressedBlockAck*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumberCyclic& startingSequenceNumber);

    virtual const ::inet::BitVector& getBlockAckBitmap() const;
    virtual ::inet::BitVector& getBlockAckBitmapForUpdate() { handleChange();return const_cast<::inet::BitVector&>(const_cast<Ieee80211CompressedBlockAck*>(this)->getBlockAckBitmap());}
    virtual void setBlockAckBitmap(const ::inet::BitVector& blockAckBitmap);

    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CompressedBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CompressedBlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:466</tt> by opp_msgtool.
 * <pre>
 * //
 * // 8.3.1.9.4 Multi-TID BlockAck variant
 * //
 * class Ieee80211MultiTidBlockAck extends Ieee80211BlockAck
 * {
 *     // chunkLength TODO
 *     multiTid = 1;
 *     compressedBitmap = 1;
 * 
 *     // TODO unimplemented
 * }
 * </pre>
 */
class INET_API Ieee80211MultiTidBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:

  private:
    void copy(const Ieee80211MultiTidBlockAck& other);

  protected:
    bool operator==(const Ieee80211MultiTidBlockAck&) = delete;

  public:
    Ieee80211MultiTidBlockAck();
    Ieee80211MultiTidBlockAck(const Ieee80211MultiTidBlockAck& other);
    virtual ~Ieee80211MultiTidBlockAck();
    Ieee80211MultiTidBlockAck& operator=(const Ieee80211MultiTidBlockAck& other);
    virtual Ieee80211MultiTidBlockAck *dup() const override {return new Ieee80211MultiTidBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MultiTidBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MultiTidBlockAck& obj) {obj.parsimUnpack(b);}


}  // namespace ieee80211
}  // namespace inet


namespace omnetpp {

inline any_ptr toAnyPtr(const inet::BitVector *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::BitVector *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::BitVector>(); }
inline any_ptr toAnyPtr(const inet::ieee80211::SequenceNumberCyclic *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::ieee80211::SequenceNumberCyclic *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ieee80211::SequenceNumberCyclic>(); }
template<> inline inet::ieee80211::Ieee80211MacTrailer *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MacTrailer*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211MacHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MacHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211OneAddressHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211OneAddressHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211AckFrame *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211AckFrame*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211TwoAddressHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211TwoAddressHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211RtsFrame *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211RtsFrame*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211CtsFrame *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211CtsFrame*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211DataOrMgmtHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211DataOrMgmtHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211DataHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211DataHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211MgmtHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MgmtHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211ActionFrame *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211ActionFrame*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211MsduSubframeHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MsduSubframeHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211MpduSubframeHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MpduSubframeHeader*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211AddbaRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211AddbaRequest*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211AddbaResponse *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211AddbaResponse*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211Delba *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211Delba*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211BlockAckReq *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211BlockAckReq*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211BasicBlockAckReq *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211BasicBlockAckReq*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211CompressedBlockAckReq *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211CompressedBlockAckReq*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211MultiTidBlockAckReq *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MultiTidBlockAckReq*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211BlockAck *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211BlockAck*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211BasicBlockAck *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211BasicBlockAck*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211CompressedBlockAck *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211CompressedBlockAck*>(ptr.get<cObject>()); }
template<> inline inet::ieee80211::Ieee80211MultiTidBlockAck *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ieee80211::Ieee80211MultiTidBlockAck*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_IEEE80211FRAME_M_H


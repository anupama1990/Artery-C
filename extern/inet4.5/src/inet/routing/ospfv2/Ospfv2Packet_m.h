//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/routing/ospfv2/Ospfv2Packet.msg.
//

#ifndef __INET__OSPFV2_OSPFV2PACKET_M_H
#define __INET__OSPFV2_OSPFV2PACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace ospfv2 {

struct Ospfv2Options;
class Ospfv2Packet;
class Ospfv2HelloPacket;
class Ospfv2LsaHeader;
class Ospfv2Lsa;
struct Ospfv2TosData;
class Ospfv2Link;
class Ospfv2RouterLsa;
class Ospfv2NetworkLsa;
class Ospfv2SummaryLsa;
struct Ospfv2ExternalTosInfo;
class Ospfv2AsExternalLsaContents;
class Ospfv2AsExternalLsa;
struct Ospfv2DdOptions;
class Ospfv2DatabaseDescriptionPacket;
struct Ospfv2LsaRequest;
class Ospfv2LinkStateRequestPacket;
class Ospfv2LinkStateUpdatePacket;
class Ospfv2LinkStateAcknowledgementPacket;

}  // namespace ospfv2
}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/routing/ospf_common/OspfPacketBase_m.h" // import inet.routing.ospf_common.OspfPacketBase

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode


namespace inet {
namespace ospfv2 {

// cplusplus {{
using namespace ospf;
// }}

/**
 * Enum generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:19</tt> by opp_msgtool.
 * <pre>
 * enum Ospfv2TimerType
 * {
 *     INTERFACE_HELLO_TIMER = 0;
 *     INTERFACE_WAIT_TIMER = 1;
 *     INTERFACE_ACKNOWLEDGEMENT_TIMER = 3;
 *     NEIGHBOR_INACTIVITY_TIMER = 4;
 *     NEIGHBOR_POLL_TIMER = 5;
 *     NEIGHBOR_DD_RETRANSMISSION_TIMER = 6;
 *     NEIGHBOR_UPDATE_RETRANSMISSION_TIMER = 7;
 *     NEIGHBOR_REQUEST_RETRANSMISSION_TIMER = 8;
 *     DATABASE_AGE_TIMER = 9;
 * }
 * </pre>
 */
enum Ospfv2TimerType {
    INTERFACE_HELLO_TIMER = 0,
    INTERFACE_WAIT_TIMER = 1,
    INTERFACE_ACKNOWLEDGEMENT_TIMER = 3,
    NEIGHBOR_INACTIVITY_TIMER = 4,
    NEIGHBOR_POLL_TIMER = 5,
    NEIGHBOR_DD_RETRANSMISSION_TIMER = 6,
    NEIGHBOR_UPDATE_RETRANSMISSION_TIMER = 7,
    NEIGHBOR_REQUEST_RETRANSMISSION_TIMER = 8,
    DATABASE_AGE_TIMER = 9
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2TimerType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2TimerType& e) { int n; b->unpack(n); e = static_cast<Ospfv2TimerType>(n); }

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:33 by opp_msgtool.
 */
struct INET_API Ospfv2Options
{
    Ospfv2Options();
    bool unused_1 = false;
    bool E_ExternalRoutingCapability = false;
    bool MC_MulticastForwarding = false;
    bool NP_Type7LSA = false;
    bool EA_ForwardExternalLSAs = false;
    bool DC_DemandCircuits = false;
    bool unused_2 = false;
    bool unused_3 = false;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2Options& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2Options& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Options& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Options& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:49</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF packet header
 * //
 * class Ospfv2Packet extends ospf::OspfPacketBase
 * {
 *     chunkLength = B(24);
 *     version = 2;
 * 
 *     short authenticationType = 0;   // 2 bytes
 *     char authentication[8];         // 8 bytes
 * }
 * </pre>
 */
class INET_API Ospfv2Packet : public ::inet::ospf::OspfPacketBase
{
  protected:
    short authenticationType = 0;
    char authentication[8] = {0};

  private:
    void copy(const Ospfv2Packet& other);

  protected:
    bool operator==(const Ospfv2Packet&) = delete;

  public:
    Ospfv2Packet();
    Ospfv2Packet(const Ospfv2Packet& other);
    virtual ~Ospfv2Packet();
    Ospfv2Packet& operator=(const Ospfv2Packet& other);
    virtual Ospfv2Packet *dup() const override {return new Ospfv2Packet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual short getAuthenticationType() const;
    virtual void setAuthenticationType(short authenticationType);

    virtual size_t getAuthenticationArraySize() const;
    virtual char getAuthentication(size_t k) const;
    virtual void setAuthentication(size_t k, char authentication);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Packet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:61</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Hello packet
 * //
 * class Ospfv2HelloPacket extends Ospfv2Packet
 * {
 *     type = HELLO_PACKET;
 *     Ipv4Address networkMask;
 * 
 *     short helloInterval = 5;
 * 
 *     Ospfv2Options options;
 * 
 *     char routerPriority = 0;
 *     long routerDeadInterval = 0;
 * 
 *     Ipv4Address designatedRouter;
 *     Ipv4Address backupDesignatedRouter;
 *     Ipv4Address neighbor[];
 * }
 * </pre>
 */
class INET_API Ospfv2HelloPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    ::inet::Ipv4Address networkMask;
    short helloInterval = 5;
    Ospfv2Options options;
    char routerPriority = 0;
    long routerDeadInterval = 0;
    ::inet::Ipv4Address designatedRouter;
    ::inet::Ipv4Address backupDesignatedRouter;
    ::inet::Ipv4Address *neighbor = nullptr;
    size_t neighbor_arraysize = 0;

  private:
    void copy(const Ospfv2HelloPacket& other);

  protected:
    bool operator==(const Ospfv2HelloPacket&) = delete;

  public:
    Ospfv2HelloPacket();
    Ospfv2HelloPacket(const Ospfv2HelloPacket& other);
    virtual ~Ospfv2HelloPacket();
    Ospfv2HelloPacket& operator=(const Ospfv2HelloPacket& other);
    virtual Ospfv2HelloPacket *dup() const override {return new Ospfv2HelloPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::Ipv4Address& getNetworkMask() const;
    virtual ::inet::Ipv4Address& getNetworkMaskForUpdate() { handleChange();return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const ::inet::Ipv4Address& networkMask);

    virtual short getHelloInterval() const;
    virtual void setHelloInterval(short helloInterval);

    virtual const Ospfv2Options& getOptions() const;
    virtual Ospfv2Options& getOptionsForUpdate() { handleChange();return const_cast<Ospfv2Options&>(const_cast<Ospfv2HelloPacket*>(this)->getOptions());}
    virtual void setOptions(const Ospfv2Options& options);

    virtual char getRouterPriority() const;
    virtual void setRouterPriority(char routerPriority);

    virtual long getRouterDeadInterval() const;
    virtual void setRouterDeadInterval(long routerDeadInterval);

    virtual const ::inet::Ipv4Address& getDesignatedRouter() const;
    virtual ::inet::Ipv4Address& getDesignatedRouterForUpdate() { handleChange();return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getDesignatedRouter());}
    virtual void setDesignatedRouter(const ::inet::Ipv4Address& designatedRouter);

    virtual const ::inet::Ipv4Address& getBackupDesignatedRouter() const;
    virtual ::inet::Ipv4Address& getBackupDesignatedRouterForUpdate() { handleChange();return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getBackupDesignatedRouter());}
    virtual void setBackupDesignatedRouter(const ::inet::Ipv4Address& backupDesignatedRouter);

    virtual void setNeighborArraySize(size_t size);
    virtual size_t getNeighborArraySize() const;
    virtual const ::inet::Ipv4Address& getNeighbor(size_t k) const;
    virtual ::inet::Ipv4Address& getNeighborForUpdate(size_t k) { handleChange();return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2HelloPacket*>(this)->getNeighbor(k));}
    virtual void setNeighbor(size_t k, const ::inet::Ipv4Address& neighbor);
    virtual void insertNeighbor(size_t k, const ::inet::Ipv4Address& neighbor);
    [[deprecated]] void insertNeighbor(const ::inet::Ipv4Address& neighbor) {appendNeighbor(neighbor);}
    virtual void appendNeighbor(const ::inet::Ipv4Address& neighbor);
    virtual void eraseNeighbor(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2HelloPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2HelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:78</tt> by opp_msgtool.
 * <pre>
 * enum Ospfv2LsaType
 * {
 *     ROUTERLSA_TYPE = 1;
 *     NETWORKLSA_TYPE = 2;
 *     SUMMARYLSA_NETWORKS_TYPE = 3;
 *     SUMMARYLSA_ASBOUNDARYROUTERS_TYPE = 4;
 *     AS_EXTERNAL_LSA_TYPE = 5;
 * }
 * </pre>
 */
enum Ospfv2LsaType {
    ROUTERLSA_TYPE = 1,
    NETWORKLSA_TYPE = 2,
    SUMMARYLSA_NETWORKS_TYPE = 3,
    SUMMARYLSA_ASBOUNDARYROUTERS_TYPE = 4,
    AS_EXTERNAL_LSA_TYPE = 5
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaType& e) { int n; b->unpack(n); e = static_cast<Ospfv2LsaType>(n); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:90</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF LSA header
 * //
 * class Ospfv2LsaHeader extends cObject
 * {
 *     \@packetData;
 *     unsigned short lsAge = 0;
 *     Ospfv2Options lsOptions;
 *     Ospfv2LsaType lsType = static_cast<Ospfv2LsaType>(-1);
 *     Ipv4Address linkStateID;
 *     Ipv4Address advertisingRouter;
 *     int32_t lsSequenceNumber = 0;
 *     uint16_t lsCrc = 0;
 *     CrcMode lsCrcMode = CRC_MODE_UNDEFINED;
 *     uint16_t lsaLength = 0;
 * }
 * </pre>
 */
class INET_API Ospfv2LsaHeader : public ::omnetpp::cObject
{
  protected:
    unsigned short lsAge = 0;
    Ospfv2Options lsOptions;
    Ospfv2LsaType lsType = static_cast<Ospfv2LsaType>(-1);
    ::inet::Ipv4Address linkStateID;
    ::inet::Ipv4Address advertisingRouter;
    int32_t lsSequenceNumber = 0;
    uint16_t lsCrc = 0;
    ::inet::CrcMode lsCrcMode = CRC_MODE_UNDEFINED;
    uint16_t lsaLength = 0;

  private:
    void copy(const Ospfv2LsaHeader& other);

  protected:
    bool operator==(const Ospfv2LsaHeader&) = delete;

  public:
    Ospfv2LsaHeader();
    Ospfv2LsaHeader(const Ospfv2LsaHeader& other);
    virtual ~Ospfv2LsaHeader();
    Ospfv2LsaHeader& operator=(const Ospfv2LsaHeader& other);
    virtual Ospfv2LsaHeader *dup() const override {return new Ospfv2LsaHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned short getLsAge() const;
    virtual void setLsAge(unsigned short lsAge);

    virtual const Ospfv2Options& getLsOptions() const;
    virtual Ospfv2Options& getLsOptionsForUpdate() { return const_cast<Ospfv2Options&>(const_cast<Ospfv2LsaHeader*>(this)->getLsOptions());}
    virtual void setLsOptions(const Ospfv2Options& lsOptions);

    virtual Ospfv2LsaType getLsType() const;
    virtual void setLsType(Ospfv2LsaType lsType);

    virtual const ::inet::Ipv4Address& getLinkStateID() const;
    virtual ::inet::Ipv4Address& getLinkStateIDForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2LsaHeader*>(this)->getLinkStateID());}
    virtual void setLinkStateID(const ::inet::Ipv4Address& linkStateID);

    virtual const ::inet::Ipv4Address& getAdvertisingRouter() const;
    virtual ::inet::Ipv4Address& getAdvertisingRouterForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2LsaHeader*>(this)->getAdvertisingRouter());}
    virtual void setAdvertisingRouter(const ::inet::Ipv4Address& advertisingRouter);

    virtual int32_t getLsSequenceNumber() const;
    virtual void setLsSequenceNumber(int32_t lsSequenceNumber);

    virtual uint16_t getLsCrc() const;
    virtual void setLsCrc(uint16_t lsCrc);

    virtual ::inet::CrcMode getLsCrcMode() const;
    virtual void setLsCrcMode(::inet::CrcMode lsCrcMode);

    virtual uint16_t getLsaLength() const;
    virtual void setLsaLength(uint16_t lsaLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:107</tt> by opp_msgtool.
 * <pre>
 * //
 * // common ancestor type for all LSAs
 * //
 * class Ospfv2Lsa extends cObject
 * {
 *     \@packetData;
 *     Ospfv2LsaHeader header;
 * }
 * </pre>
 */
class INET_API Ospfv2Lsa : public ::omnetpp::cObject
{
  protected:
    Ospfv2LsaHeader header;

  private:
    void copy(const Ospfv2Lsa& other);

  protected:
    bool operator==(const Ospfv2Lsa&) = delete;

  public:
    Ospfv2Lsa();
    Ospfv2Lsa(const Ospfv2Lsa& other);
    virtual ~Ospfv2Lsa();
    Ospfv2Lsa& operator=(const Ospfv2Lsa& other);
    virtual Ospfv2Lsa *dup() const override {return new Ospfv2Lsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const Ospfv2LsaHeader& getHeader() const;
    virtual Ospfv2LsaHeader& getHeaderForUpdate() { return const_cast<Ospfv2LsaHeader&>(const_cast<Ospfv2Lsa*>(this)->getHeader());}
    virtual void setHeader(const Ospfv2LsaHeader& header);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Lsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Lsa& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:113</tt> by opp_msgtool.
 * <pre>
 * enum LinkType
 * {
 *     POINTTOPOINT_LINK = 1;
 *     TRANSIT_LINK = 2;
 *     STUB_LINK = 3;
 *     VIRTUAL_LINK = 4;
 * }
 * </pre>
 */
enum LinkType {
    POINTTOPOINT_LINK = 1,
    TRANSIT_LINK = 2,
    STUB_LINK = 3,
    VIRTUAL_LINK = 4
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LinkType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LinkType& e) { int n; b->unpack(n); e = static_cast<LinkType>(n); }

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:122 by opp_msgtool.
 */
struct INET_API Ospfv2TosData
{
    Ospfv2TosData();
    unsigned char tos = 0;
    unsigned long tosMetric = 0;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2TosData& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2TosData& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2TosData& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2TosData& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:130</tt> by opp_msgtool.
 * <pre>
 * // Router LSA Link section (RFC 1583 Section A.4.2.)
 * class Ospfv2Link extends cObject
 * {
 *     \@packetData;
 *     Ipv4Address linkID;
 *     unsigned long linkData = 0;
 *     LinkType type = POINTTOPOINT_LINK;
 *     unsigned char numberOfTOS = 0;
 *     unsigned long linkCost = 1;     // TOS 0 metric
 *     Ospfv2TosData tosData[];
 * }
 * </pre>
 */
class INET_API Ospfv2Link : public ::omnetpp::cObject
{
  protected:
    ::inet::Ipv4Address linkID;
    unsigned long linkData = 0;
    LinkType type = POINTTOPOINT_LINK;
    unsigned char numberOfTOS = 0;
    unsigned long linkCost = 1;
    Ospfv2TosData *tosData = nullptr;
    size_t tosData_arraysize = 0;

  private:
    void copy(const Ospfv2Link& other);

  protected:
    bool operator==(const Ospfv2Link&) = delete;

  public:
    Ospfv2Link();
    Ospfv2Link(const Ospfv2Link& other);
    virtual ~Ospfv2Link();
    Ospfv2Link& operator=(const Ospfv2Link& other);
    virtual Ospfv2Link *dup() const override {return new Ospfv2Link(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::Ipv4Address& getLinkID() const;
    virtual ::inet::Ipv4Address& getLinkIDForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2Link*>(this)->getLinkID());}
    virtual void setLinkID(const ::inet::Ipv4Address& linkID);

    virtual unsigned long getLinkData() const;
    virtual void setLinkData(unsigned long linkData);

    virtual LinkType getType() const;
    virtual void setType(LinkType type);

    virtual unsigned char getNumberOfTOS() const;
    virtual void setNumberOfTOS(unsigned char numberOfTOS);

    virtual unsigned long getLinkCost() const;
    virtual void setLinkCost(unsigned long linkCost);

    virtual void setTosDataArraySize(size_t size);
    virtual size_t getTosDataArraySize() const;
    virtual const Ospfv2TosData& getTosData(size_t k) const;
    virtual Ospfv2TosData& getTosDataForUpdate(size_t k) { return const_cast<Ospfv2TosData&>(const_cast<Ospfv2Link*>(this)->getTosData(k));}
    virtual void setTosData(size_t k, const Ospfv2TosData& tosData);
    virtual void insertTosData(size_t k, const Ospfv2TosData& tosData);
    [[deprecated]] void insertTosData(const Ospfv2TosData& tosData) {appendTosData(tosData);}
    virtual void appendTosData(const Ospfv2TosData& tosData);
    virtual void eraseTosData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2Link& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2Link& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:144</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Router LSA (RFC 1583 Section A.4.2.)
 * //
 * class Ospfv2RouterLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = ROUTERLSA_TYPE;
 *     unsigned short reserved1 = 0;   // 5 bit
 *     bool V_VirtualLinkEndpoint = false;
 *     bool E_ASBoundaryRouter = false;
 *     bool B_AreaBorderRouter = false;
 *     unsigned short reserved2 = 0;   // 8 bit
 *     unsigned short numberOfLinks = 0;
 *     Ospfv2Link links[];
 * }
 * </pre>
 */
class INET_API Ospfv2RouterLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    unsigned short reserved1 = 0;
    bool V_VirtualLinkEndpoint = false;
    bool E_ASBoundaryRouter = false;
    bool B_AreaBorderRouter = false;
    unsigned short reserved2 = 0;
    unsigned short numberOfLinks = 0;
    Ospfv2Link *links = nullptr;
    size_t links_arraysize = 0;

  private:
    void copy(const Ospfv2RouterLsa& other);

  protected:
    bool operator==(const Ospfv2RouterLsa&) = delete;

  public:
    Ospfv2RouterLsa();
    Ospfv2RouterLsa(const Ospfv2RouterLsa& other);
    virtual ~Ospfv2RouterLsa();
    Ospfv2RouterLsa& operator=(const Ospfv2RouterLsa& other);
    virtual Ospfv2RouterLsa *dup() const override {return new Ospfv2RouterLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned short getReserved1() const;
    virtual void setReserved1(unsigned short reserved1);

    virtual bool getV_VirtualLinkEndpoint() const;
    virtual void setV_VirtualLinkEndpoint(bool V_VirtualLinkEndpoint);

    virtual bool getE_ASBoundaryRouter() const;
    virtual void setE_ASBoundaryRouter(bool E_ASBoundaryRouter);

    virtual bool getB_AreaBorderRouter() const;
    virtual void setB_AreaBorderRouter(bool B_AreaBorderRouter);

    virtual unsigned short getReserved2() const;
    virtual void setReserved2(unsigned short reserved2);

    virtual unsigned short getNumberOfLinks() const;
    virtual void setNumberOfLinks(unsigned short numberOfLinks);

    virtual void setLinksArraySize(size_t size);
    virtual size_t getLinksArraySize() const;
    virtual const Ospfv2Link& getLinks(size_t k) const;
    virtual Ospfv2Link& getLinksForUpdate(size_t k) { return const_cast<Ospfv2Link&>(const_cast<Ospfv2RouterLsa*>(this)->getLinks(k));}
    virtual void setLinks(size_t k, const Ospfv2Link& links);
    virtual void insertLinks(size_t k, const Ospfv2Link& links);
    [[deprecated]] void insertLinks(const Ospfv2Link& links) {appendLinks(links);}
    virtual void appendLinks(const Ospfv2Link& links);
    virtual void eraseLinks(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2RouterLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2RouterLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:159</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Network LSA
 * //
 * class Ospfv2NetworkLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = NETWORKLSA_TYPE;
 *     Ipv4Address networkMask;
 *     Ipv4Address attachedRouters[];
 * }
 * </pre>
 */
class INET_API Ospfv2NetworkLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    ::inet::Ipv4Address networkMask;
    ::inet::Ipv4Address *attachedRouters = nullptr;
    size_t attachedRouters_arraysize = 0;

  private:
    void copy(const Ospfv2NetworkLsa& other);

  protected:
    bool operator==(const Ospfv2NetworkLsa&) = delete;

  public:
    Ospfv2NetworkLsa();
    Ospfv2NetworkLsa(const Ospfv2NetworkLsa& other);
    virtual ~Ospfv2NetworkLsa();
    Ospfv2NetworkLsa& operator=(const Ospfv2NetworkLsa& other);
    virtual Ospfv2NetworkLsa *dup() const override {return new Ospfv2NetworkLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::Ipv4Address& getNetworkMask() const;
    virtual ::inet::Ipv4Address& getNetworkMaskForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2NetworkLsa*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const ::inet::Ipv4Address& networkMask);

    virtual void setAttachedRoutersArraySize(size_t size);
    virtual size_t getAttachedRoutersArraySize() const;
    virtual const ::inet::Ipv4Address& getAttachedRouters(size_t k) const;
    virtual ::inet::Ipv4Address& getAttachedRoutersForUpdate(size_t k) { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2NetworkLsa*>(this)->getAttachedRouters(k));}
    virtual void setAttachedRouters(size_t k, const ::inet::Ipv4Address& attachedRouters);
    virtual void insertAttachedRouters(size_t k, const ::inet::Ipv4Address& attachedRouters);
    [[deprecated]] void insertAttachedRouters(const ::inet::Ipv4Address& attachedRouters) {appendAttachedRouters(attachedRouters);}
    virtual void appendAttachedRouters(const ::inet::Ipv4Address& attachedRouters);
    virtual void eraseAttachedRouters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2NetworkLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2NetworkLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:169</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Summary LSA
 * //
 * class Ospfv2SummaryLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = SUMMARYLSA_NETWORKS_TYPE;
 *     Ipv4Address networkMask;
 *     unsigned long routeCost = 1;
 *     Ospfv2TosData tosData[];  // 1 element required, count of tosData not stored, calculate it from length of LSA
 * }
 * </pre>
 */
class INET_API Ospfv2SummaryLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    ::inet::Ipv4Address networkMask;
    unsigned long routeCost = 1;
    Ospfv2TosData *tosData = nullptr;
    size_t tosData_arraysize = 0;

  private:
    void copy(const Ospfv2SummaryLsa& other);

  protected:
    bool operator==(const Ospfv2SummaryLsa&) = delete;

  public:
    Ospfv2SummaryLsa();
    Ospfv2SummaryLsa(const Ospfv2SummaryLsa& other);
    virtual ~Ospfv2SummaryLsa();
    Ospfv2SummaryLsa& operator=(const Ospfv2SummaryLsa& other);
    virtual Ospfv2SummaryLsa *dup() const override {return new Ospfv2SummaryLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::Ipv4Address& getNetworkMask() const;
    virtual ::inet::Ipv4Address& getNetworkMaskForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2SummaryLsa*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const ::inet::Ipv4Address& networkMask);

    virtual unsigned long getRouteCost() const;
    virtual void setRouteCost(unsigned long routeCost);

    virtual void setTosDataArraySize(size_t size);
    virtual size_t getTosDataArraySize() const;
    virtual const Ospfv2TosData& getTosData(size_t k) const;
    virtual Ospfv2TosData& getTosDataForUpdate(size_t k) { return const_cast<Ospfv2TosData&>(const_cast<Ospfv2SummaryLsa*>(this)->getTosData(k));}
    virtual void setTosData(size_t k, const Ospfv2TosData& tosData);
    virtual void insertTosData(size_t k, const Ospfv2TosData& tosData);
    [[deprecated]] void insertTosData(const Ospfv2TosData& tosData) {appendTosData(tosData);}
    virtual void appendTosData(const Ospfv2TosData& tosData);
    virtual void eraseTosData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2SummaryLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2SummaryLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:177 by opp_msgtool.
 */
struct INET_API Ospfv2ExternalTosInfo
{
    Ospfv2ExternalTosInfo();
    unsigned short tos = 0;
    bool E_ExternalMetricType = false;
    unsigned long routeCost = 1;
    ::inet::Ipv4Address forwardingAddress;
    long externalRouteTag = 0;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2ExternalTosInfo& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2ExternalTosInfo& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2ExternalTosInfo& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2ExternalTosInfo& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:191</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents the contents of an OSPF AS External LSA
 * //
 * class Ospfv2AsExternalLsaContents extends cObject
 * {
 *     \@packetData;
 *     Ipv4Address networkMask;
 *     Ospfv2ExternalTosInfo externalTOSInfo[];
 * }
 * </pre>
 */
class INET_API Ospfv2AsExternalLsaContents : public ::omnetpp::cObject
{
  protected:
    ::inet::Ipv4Address networkMask;
    Ospfv2ExternalTosInfo *externalTOSInfo = nullptr;
    size_t externalTOSInfo_arraysize = 0;

  private:
    void copy(const Ospfv2AsExternalLsaContents& other);

  protected:
    bool operator==(const Ospfv2AsExternalLsaContents&) = delete;

  public:
    Ospfv2AsExternalLsaContents();
    Ospfv2AsExternalLsaContents(const Ospfv2AsExternalLsaContents& other);
    virtual ~Ospfv2AsExternalLsaContents();
    Ospfv2AsExternalLsaContents& operator=(const Ospfv2AsExternalLsaContents& other);
    virtual Ospfv2AsExternalLsaContents *dup() const override {return new Ospfv2AsExternalLsaContents(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::Ipv4Address& getNetworkMask() const;
    virtual ::inet::Ipv4Address& getNetworkMaskForUpdate() { return const_cast<::inet::Ipv4Address&>(const_cast<Ospfv2AsExternalLsaContents*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const ::inet::Ipv4Address& networkMask);

    virtual void setExternalTOSInfoArraySize(size_t size);
    virtual size_t getExternalTOSInfoArraySize() const;
    virtual const Ospfv2ExternalTosInfo& getExternalTOSInfo(size_t k) const;
    virtual Ospfv2ExternalTosInfo& getExternalTOSInfoForUpdate(size_t k) { return const_cast<Ospfv2ExternalTosInfo&>(const_cast<Ospfv2AsExternalLsaContents*>(this)->getExternalTOSInfo(k));}
    virtual void setExternalTOSInfo(size_t k, const Ospfv2ExternalTosInfo& externalTOSInfo);
    virtual void insertExternalTOSInfo(size_t k, const Ospfv2ExternalTosInfo& externalTOSInfo);
    [[deprecated]] void insertExternalTOSInfo(const Ospfv2ExternalTosInfo& externalTOSInfo) {appendExternalTOSInfo(externalTOSInfo);}
    virtual void appendExternalTOSInfo(const Ospfv2ExternalTosInfo& externalTOSInfo);
    virtual void eraseExternalTOSInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2AsExternalLsaContents& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2AsExternalLsaContents& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:201</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF AS External LSA
 * //
 * class Ospfv2AsExternalLsa extends Ospfv2Lsa
 * {
 *     // header.lsType = AS_EXTERNAL_LSA_TYPE;
 *     Ospfv2AsExternalLsaContents contents;
 * }
 * </pre>
 */
class INET_API Ospfv2AsExternalLsa : public ::inet::ospfv2::Ospfv2Lsa
{
  protected:
    Ospfv2AsExternalLsaContents contents;

  private:
    void copy(const Ospfv2AsExternalLsa& other);

  protected:
    bool operator==(const Ospfv2AsExternalLsa&) = delete;

  public:
    Ospfv2AsExternalLsa();
    Ospfv2AsExternalLsa(const Ospfv2AsExternalLsa& other);
    virtual ~Ospfv2AsExternalLsa();
    Ospfv2AsExternalLsa& operator=(const Ospfv2AsExternalLsa& other);
    virtual Ospfv2AsExternalLsa *dup() const override {return new Ospfv2AsExternalLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const Ospfv2AsExternalLsaContents& getContents() const;
    virtual Ospfv2AsExternalLsaContents& getContentsForUpdate() { return const_cast<Ospfv2AsExternalLsaContents&>(const_cast<Ospfv2AsExternalLsa*>(this)->getContents());}
    virtual void setContents(const Ospfv2AsExternalLsaContents& contents);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2AsExternalLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2AsExternalLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:208 by opp_msgtool.
 */
struct INET_API Ospfv2DdOptions
{
    Ospfv2DdOptions();
    unsigned short unused = 0;
    bool I_Init = false;
    bool M_More = false;
    bool MS_MasterSlave = false;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2DdOptions& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2DdOptions& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2DdOptions& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2DdOptions& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:220</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Database Description packet
 * //
 * class Ospfv2DatabaseDescriptionPacket extends Ospfv2Packet
 * {
 *     unsigned short interfaceMTU;
 *     Ospfv2Options options;
 *     Ospfv2DdOptions ddOptions;
 *     unsigned long ddSequenceNumber;
 *     Ospfv2LsaHeader lsaHeaders[];     //TODO
 * }
 * </pre>
 */
class INET_API Ospfv2DatabaseDescriptionPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    unsigned short interfaceMTU = 0;
    Ospfv2Options options;
    Ospfv2DdOptions ddOptions;
    unsigned long ddSequenceNumber = 0;
    Ospfv2LsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const Ospfv2DatabaseDescriptionPacket& other);

  protected:
    bool operator==(const Ospfv2DatabaseDescriptionPacket&) = delete;

  public:
    Ospfv2DatabaseDescriptionPacket();
    Ospfv2DatabaseDescriptionPacket(const Ospfv2DatabaseDescriptionPacket& other);
    virtual ~Ospfv2DatabaseDescriptionPacket();
    Ospfv2DatabaseDescriptionPacket& operator=(const Ospfv2DatabaseDescriptionPacket& other);
    virtual Ospfv2DatabaseDescriptionPacket *dup() const override {return new Ospfv2DatabaseDescriptionPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned short getInterfaceMTU() const;
    virtual void setInterfaceMTU(unsigned short interfaceMTU);

    virtual const Ospfv2Options& getOptions() const;
    virtual Ospfv2Options& getOptionsForUpdate() { handleChange();return const_cast<Ospfv2Options&>(const_cast<Ospfv2DatabaseDescriptionPacket*>(this)->getOptions());}
    virtual void setOptions(const Ospfv2Options& options);

    virtual const Ospfv2DdOptions& getDdOptions() const;
    virtual Ospfv2DdOptions& getDdOptionsForUpdate() { handleChange();return const_cast<Ospfv2DdOptions&>(const_cast<Ospfv2DatabaseDescriptionPacket*>(this)->getDdOptions());}
    virtual void setDdOptions(const Ospfv2DdOptions& ddOptions);

    virtual unsigned long getDdSequenceNumber() const;
    virtual void setDdSequenceNumber(unsigned long ddSequenceNumber);

    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const Ospfv2LsaHeader& getLsaHeaders(size_t k) const;
    virtual Ospfv2LsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<Ospfv2LsaHeader&>(const_cast<Ospfv2DatabaseDescriptionPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    [[deprecated]] void insertLsaHeaders(const Ospfv2LsaHeader& lsaHeaders) {appendLsaHeaders(lsaHeaders);}
    virtual void appendLsaHeaders(const Ospfv2LsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2DatabaseDescriptionPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2DatabaseDescriptionPacket& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/Ospfv2Packet.msg:229 by opp_msgtool.
 */
struct INET_API Ospfv2LsaRequest
{
    Ospfv2LsaRequest();
    unsigned long lsType = 0;
    ::inet::Ipv4Address linkStateID;
    ::inet::Ipv4Address advertisingRouter;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaRequest& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaRequest& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LsaRequest& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LsaRequest& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:240</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Request packet
 * //
 * class Ospfv2LinkStateRequestPacket extends Ospfv2Packet
 * {
 *     Ospfv2LsaRequest requests[];
 * }
 * </pre>
 */
class INET_API Ospfv2LinkStateRequestPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ospfv2LsaRequest *requests = nullptr;
    size_t requests_arraysize = 0;

  private:
    void copy(const Ospfv2LinkStateRequestPacket& other);

  protected:
    bool operator==(const Ospfv2LinkStateRequestPacket&) = delete;

  public:
    Ospfv2LinkStateRequestPacket();
    Ospfv2LinkStateRequestPacket(const Ospfv2LinkStateRequestPacket& other);
    virtual ~Ospfv2LinkStateRequestPacket();
    Ospfv2LinkStateRequestPacket& operator=(const Ospfv2LinkStateRequestPacket& other);
    virtual Ospfv2LinkStateRequestPacket *dup() const override {return new Ospfv2LinkStateRequestPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setRequestsArraySize(size_t size);
    virtual size_t getRequestsArraySize() const;
    virtual const Ospfv2LsaRequest& getRequests(size_t k) const;
    virtual Ospfv2LsaRequest& getRequestsForUpdate(size_t k) { handleChange();return const_cast<Ospfv2LsaRequest&>(const_cast<Ospfv2LinkStateRequestPacket*>(this)->getRequests(k));}
    virtual void setRequests(size_t k, const Ospfv2LsaRequest& requests);
    virtual void insertRequests(size_t k, const Ospfv2LsaRequest& requests);
    [[deprecated]] void insertRequests(const Ospfv2LsaRequest& requests) {appendRequests(requests);}
    virtual void appendRequests(const Ospfv2LsaRequest& requests);
    virtual void eraseRequests(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LinkStateRequestPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LinkStateRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:248</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Update packet
 * //
 * class Ospfv2LinkStateUpdatePacket extends Ospfv2Packet
 * {
 *     Ospfv2Lsa *ospfLSAs[] \@owned \@allowReplace;
 * }
 * </pre>
 */
class INET_API Ospfv2LinkStateUpdatePacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ospfv2Lsa * *ospfLSAs = nullptr;
    size_t ospfLSAs_arraysize = 0;

  private:
    void copy(const Ospfv2LinkStateUpdatePacket& other);

  protected:
    bool operator==(const Ospfv2LinkStateUpdatePacket&) = delete;

  public:
    Ospfv2LinkStateUpdatePacket();
    Ospfv2LinkStateUpdatePacket(const Ospfv2LinkStateUpdatePacket& other);
    virtual ~Ospfv2LinkStateUpdatePacket();
    Ospfv2LinkStateUpdatePacket& operator=(const Ospfv2LinkStateUpdatePacket& other);
    virtual Ospfv2LinkStateUpdatePacket *dup() const override {return new Ospfv2LinkStateUpdatePacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setOspfLSAsArraySize(size_t size);
    virtual size_t getOspfLSAsArraySize() const;
    virtual const Ospfv2Lsa * getOspfLSAs(size_t k) const;
    virtual Ospfv2Lsa * getOspfLSAsForUpdate(size_t k) { handleChange();return const_cast<Ospfv2Lsa *>(const_cast<Ospfv2LinkStateUpdatePacket*>(this)->getOspfLSAs(k));}
    virtual void setOspfLSAs(size_t k, Ospfv2Lsa * ospfLSAs);
    virtual Ospfv2Lsa * removeOspfLSAs(size_t k);
    [[deprecated]] Ospfv2Lsa * dropOspfLSAs(size_t k) {return removeOspfLSAs(k);}
    virtual void insertOspfLSAs(size_t k, Ospfv2Lsa * ospfLSAs);
    [[deprecated]] void insertOspfLSAs(Ospfv2Lsa * ospfLSAs) {appendOspfLSAs(ospfLSAs);}
    virtual void appendOspfLSAs(Ospfv2Lsa * ospfLSAs);
    virtual void eraseOspfLSAs(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LinkStateUpdatePacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LinkStateUpdatePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/Ospfv2Packet.msg:256</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Acknowledgement packet
 * //
 * class Ospfv2LinkStateAcknowledgementPacket extends Ospfv2Packet
 * {
 *     Ospfv2LsaHeader lsaHeaders[];     //TODO
 * }
 * </pre>
 */
class INET_API Ospfv2LinkStateAcknowledgementPacket : public ::inet::ospfv2::Ospfv2Packet
{
  protected:
    Ospfv2LsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const Ospfv2LinkStateAcknowledgementPacket& other);

  protected:
    bool operator==(const Ospfv2LinkStateAcknowledgementPacket&) = delete;

  public:
    Ospfv2LinkStateAcknowledgementPacket();
    Ospfv2LinkStateAcknowledgementPacket(const Ospfv2LinkStateAcknowledgementPacket& other);
    virtual ~Ospfv2LinkStateAcknowledgementPacket();
    Ospfv2LinkStateAcknowledgementPacket& operator=(const Ospfv2LinkStateAcknowledgementPacket& other);
    virtual Ospfv2LinkStateAcknowledgementPacket *dup() const override {return new Ospfv2LinkStateAcknowledgementPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const Ospfv2LsaHeader& getLsaHeaders(size_t k) const;
    virtual Ospfv2LsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<Ospfv2LsaHeader&>(const_cast<Ospfv2LinkStateAcknowledgementPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const Ospfv2LsaHeader& lsaHeaders);
    [[deprecated]] void insertLsaHeaders(const Ospfv2LsaHeader& lsaHeaders) {appendLsaHeaders(lsaHeaders);}
    virtual void appendLsaHeaders(const Ospfv2LsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ospfv2LinkStateAcknowledgementPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ospfv2LinkStateAcknowledgementPacket& obj) {obj.parsimUnpack(b);}


}  // namespace ospfv2
}  // namespace inet


namespace omnetpp {

inline any_ptr toAnyPtr(const inet::ospfv2::Ospfv2Options *p) {return any_ptr(p);}
template<> inline inet::ospfv2::Ospfv2Options *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ospfv2::Ospfv2Options>(); }
template<> inline inet::ospfv2::Ospfv2Packet *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2Packet*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2HelloPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2HelloPacket*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2LsaHeader *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2LsaHeader*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2Lsa *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2Lsa*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::ospfv2::Ospfv2TosData *p) {return any_ptr(p);}
template<> inline inet::ospfv2::Ospfv2TosData *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ospfv2::Ospfv2TosData>(); }
template<> inline inet::ospfv2::Ospfv2Link *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2Link*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2RouterLsa *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2RouterLsa*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2NetworkLsa *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2NetworkLsa*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2SummaryLsa *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2SummaryLsa*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::ospfv2::Ospfv2ExternalTosInfo *p) {return any_ptr(p);}
template<> inline inet::ospfv2::Ospfv2ExternalTosInfo *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ospfv2::Ospfv2ExternalTosInfo>(); }
template<> inline inet::ospfv2::Ospfv2AsExternalLsaContents *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2AsExternalLsaContents*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2AsExternalLsa *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2AsExternalLsa*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::ospfv2::Ospfv2DdOptions *p) {return any_ptr(p);}
template<> inline inet::ospfv2::Ospfv2DdOptions *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ospfv2::Ospfv2DdOptions>(); }
template<> inline inet::ospfv2::Ospfv2DatabaseDescriptionPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2DatabaseDescriptionPacket*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::ospfv2::Ospfv2LsaRequest *p) {return any_ptr(p);}
template<> inline inet::ospfv2::Ospfv2LsaRequest *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::ospfv2::Ospfv2LsaRequest>(); }
template<> inline inet::ospfv2::Ospfv2LinkStateRequestPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2LinkStateRequestPacket*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2LinkStateUpdatePacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2LinkStateUpdatePacket*>(ptr.get<cObject>()); }
template<> inline inet::ospfv2::Ospfv2LinkStateAcknowledgementPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::ospfv2::Ospfv2LinkStateAcknowledgementPacket*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET__OSPFV2_OSPFV2PACKET_M_H


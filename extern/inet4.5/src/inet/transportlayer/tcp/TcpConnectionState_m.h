//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/transportlayer/tcp/TcpConnectionState.msg.
//

#ifndef __INET__TCP_TCPCONNECTIONSTATE_M_H
#define __INET__TCP_TCPCONNECTIONSTATE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace tcp {

struct TcpStateVariables;

}  // namespace tcp
}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/transportlayer/tcp_common/TcpHeader_m.h" // import inet.transportlayer.tcp_common.TcpHeader


namespace inet {
namespace tcp {

// cplusplus {{
typedef std::list<Sack> SackList;
// }}

/**
 * Enum generated from <tt>inet/transportlayer/tcp/TcpConnectionState.msg:38</tt> by opp_msgtool.
 * <pre>
 * //
 * // TCP FSM states
 * //
 * // Brief descriptions (cf RFC 793, page 20):
 * //
 * // LISTEN - waiting for a connection request
 * // SYN-SENT - part of 3-way handshake (waiting for peer's SYN+ACK or SYN)
 * // SYN-RECEIVED - part of 3-way handshake (we sent SYN too, waiting for it to be acked)
 * // ESTABLISHED - normal data transfer
 * // FIN-WAIT-1 - FIN sent, waiting for its ACK (or peer's FIN)
 * // FIN-WAIT-2 - our side of the connection closed (our FIN acked), waiting for peer's FIN
 * // CLOSE-WAIT - FIN received and acked, waiting for local user to close
 * // LAST-ACK - remote side closed, FIN sent, waiting for its ACK
 * // CLOSING - simultaneous close: sent FIN, then got peer's FIN
 * // TIME-WAIT - both FIN's acked, waiting for some time to be sure remote TCP received our ACK
 * // CLOSED - represents no connection state at all.
 * //
 * // Note: FIN-WAIT-1, FIN-WAIT-2, CLOSING, TIME-WAIT represents active close (that is,
 * // local user closes first), and CLOSE-WAIT and LAST-ACK represents passive close.
 * //
 * enum TcpState
 * {
 *     TCP_S_INIT = 0;
 *     TCP_S_CLOSED = 1;
 *     TCP_S_LISTEN = 2;
 *     TCP_S_SYN_SENT = 3;
 *     TCP_S_SYN_RCVD = 4;
 *     TCP_S_ESTABLISHED = 5;
 *     TCP_S_CLOSE_WAIT = 6;
 *     TCP_S_LAST_ACK = 7;
 *     TCP_S_FIN_WAIT_1 = 8;
 *     TCP_S_FIN_WAIT_2 = 9;
 *     TCP_S_CLOSING = 10;
 *     TCP_S_TIME_WAIT = 11;
 * }
 * </pre>
 */
enum TcpState {
    TCP_S_INIT = 0,
    TCP_S_CLOSED = 1,
    TCP_S_LISTEN = 2,
    TCP_S_SYN_SENT = 3,
    TCP_S_SYN_RCVD = 4,
    TCP_S_ESTABLISHED = 5,
    TCP_S_CLOSE_WAIT = 6,
    TCP_S_LAST_ACK = 7,
    TCP_S_FIN_WAIT_1 = 8,
    TCP_S_FIN_WAIT_2 = 9,
    TCP_S_CLOSING = 10,
    TCP_S_TIME_WAIT = 11
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TcpState& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TcpState& e) { int n; b->unpack(n); e = static_cast<TcpState>(n); }

/**
 * Enum generated from <tt>inet/transportlayer/tcp/TcpConnectionState.msg:57</tt> by opp_msgtool.
 * <pre>
 * //
 * // Event, strictly for the FSM state transition purposes.
 * // DO NOT USE outside performStateTransition()!
 * //
 * enum TcpEventCode
 * {
 *     TCP_E_IGNORE = 0;
 * 
 *     // app commands
 *     // (Note: no RECEIVE command, data are automatically passed up)
 *     TCP_E_OPEN_ACTIVE = 1;
 *     TCP_E_OPEN_PASSIVE = 2;
 *     TCP_E_ACCEPT = 3;
 *     TCP_E_SEND = 4;
 *     TCP_E_CLOSE = 5;
 *     TCP_E_ABORT = 6;
 *     TCP_E_DESTROY = 7;
 *     TCP_E_STATUS = 8;
 *     TCP_E_QUEUE_BYTES_LIMIT = 9;
 *     TCP_E_READ = 10;
 *     TCP_E_SETOPTION = 11;
 * 
 *     // TPDU types
 *     TCP_E_RCV_DATA = 12;
 *     TCP_E_RCV_ACK = 13;
 *     TCP_E_RCV_SYN = 14;
 *     TCP_E_RCV_SYN_ACK = 15;
 *     TCP_E_RCV_FIN = 16;
 *     TCP_E_RCV_FIN_ACK = 17;
 *     TCP_E_RCV_RST = 18; // covers RST+ACK too
 * 
 *     TCP_E_RCV_UNEXP_SYN = 19; // unexpected SYN
 * 
 *     // timers
 *     TCP_E_TIMEOUT_2MSL = 20; // RFC 793, a.k.a. TIME-WAIT timer
 *     TCP_E_TIMEOUT_CONN_ESTAB = 21;
 *     TCP_E_TIMEOUT_FIN_WAIT_2 = 22;
 * 
 *     // All other timers (REXMT, PERSIST, DELAYED-ACK, KEEP-ALIVE, etc.),
 *     // are handled in TcpAlgorithm.
 * }
 * </pre>
 */
enum TcpEventCode {
    TCP_E_IGNORE = 0,
    TCP_E_OPEN_ACTIVE = 1,
    TCP_E_OPEN_PASSIVE = 2,
    TCP_E_ACCEPT = 3,
    TCP_E_SEND = 4,
    TCP_E_CLOSE = 5,
    TCP_E_ABORT = 6,
    TCP_E_DESTROY = 7,
    TCP_E_STATUS = 8,
    TCP_E_QUEUE_BYTES_LIMIT = 9,
    TCP_E_READ = 10,
    TCP_E_SETOPTION = 11,
    TCP_E_RCV_DATA = 12,
    TCP_E_RCV_ACK = 13,
    TCP_E_RCV_SYN = 14,
    TCP_E_RCV_SYN_ACK = 15,
    TCP_E_RCV_FIN = 16,
    TCP_E_RCV_FIN_ACK = 17,
    TCP_E_RCV_RST = 18,
    TCP_E_RCV_UNEXP_SYN = 19,
    TCP_E_TIMEOUT_2MSL = 20,
    TCP_E_TIMEOUT_CONN_ESTAB = 21,
    TCP_E_TIMEOUT_FIN_WAIT_2 = 22
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TcpEventCode& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TcpEventCode& e) { int n; b->unpack(n); e = static_cast<TcpEventCode>(n); }

/**
 * Struct generated from inet/transportlayer/tcp/TcpConnectionState.msg:108 by opp_msgtool.
 */
struct INET_API TcpStateVariables : omnetpp::cObject
{
    TcpStateVariables();
    bool active = false;
    bool fork = false;
    uint32_t snd_mss = 0;
    uint32_t snd_una = 0;
    uint32_t snd_nxt = 0;
    uint32_t snd_max = 0;
    uint32_t snd_wnd = 0;
    uint32_t snd_up = 0;
    uint32_t snd_wl1 = 0;
    uint32_t snd_wl2 = 0;
    uint32_t iss = 0;
    uint32_t rcv_nxt = 0;
    uint32_t rcv_wnd = 0;
    uint32_t rcv_up = 0;
    uint32_t irs = 0;
    uint32_t rcv_adv = 0;
    int syn_rexmit_count = 0;
    ::omnetpp::simtime_t syn_rexmit_timeout = SIMTIME_ZERO;
    bool fin_ack_rcvd = false;
    bool send_fin = false;
    uint32_t snd_fin_seq = 0;
    bool fin_rcvd = false;
    uint32_t rcv_fin_seq = 0;
    bool nagle_enabled = false;
    bool delayed_acks_enabled = false;
    bool limited_transmit_enabled = false;
    bool increased_IW_enabled = false;
    uint32_t full_sized_segment_counter = 0;
    bool ack_now = false;
    bool afterRto = false;
    bool ws_support = false;
    bool ws_enabled = false;
    int ws_manual_scale = -1;
    bool snd_ws = false;
    bool rcv_ws = false;
    unsigned int rcv_wnd_scale = 0;
    unsigned int snd_wnd_scale = 0;
    bool ts_support = false;
    bool ts_enabled = false;
    bool snd_initial_ts = false;
    bool rcv_initial_ts = false;
    uint32_t ts_recent = 0;
    uint32_t last_ack_sent = 0;
    ::omnetpp::simtime_t time_last_data_sent = SIMTIME_ZERO;
    bool sack_support = false;
    bool sack_enabled = false;
    bool snd_sack_perm = false;
    bool rcv_sack_perm = false;
    uint32_t start_seqno = 0;
    uint32_t end_seqno = 0;
    bool snd_sack = false;
    bool snd_dsack = false;
    SackList sacks_array;
    uint32_t highRxt = 0;
    uint32_t pipe = 0;
    uint32_t recoveryPoint = 0;
    uint32_t sackedBytes = 0;
    uint32_t sackedBytes_old = 0;
    bool lossRecovery = false;
    uint32_t sendQueueLimit = 0;
    bool queueUpdate = true;
    uint32_t dupacks = 0;
    uint32_t snd_sacks = 0;
    uint32_t rcv_sacks = 0;
    uint32_t rcv_oooseg = 0;
    uint32_t rcv_naseg = 0;
    uint32_t maxRcvBuffer = 0;
    uint32_t usedRcvBuffer = 0;
    uint32_t freeRcvBuffer = 0;
    uint32_t tcpRcvQueueDrops = 0;
    bool ecnEchoState = false;
    bool sndCwr = false;
    bool gotEce = false;
    bool gotCeIndication = false;
    bool ect = false;
    bool endPointIsWillingECN = false;
    bool ecnSynSent = false;
    bool ecnWillingness = false;
    bool sndAck = false;
    bool rexmit = false;
    ::omnetpp::simtime_t eceReactionTime = SIMTIME_ZERO;
    uint32_t dupthresh = 0;

  public:
    virtual ~TcpStateVariables();
    virtual std::string str() const override;
    virtual std::string detailedInfo() const;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const TcpStateVariables& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, TcpStateVariables& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TcpStateVariables& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TcpStateVariables& obj) { __doUnpacking(b, obj); }


}  // namespace tcp
}  // namespace inet


namespace omnetpp {

inline any_ptr toAnyPtr(const inet::tcp::SackList *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::tcp::SackList *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::tcp::SackList>(); }
template<> inet::tcp::TcpStateVariables *fromAnyPtr(any_ptr ptr);

}  // namespace omnetpp

#endif // ifndef __INET__TCP_TCPCONNECTIONSTATE_M_H


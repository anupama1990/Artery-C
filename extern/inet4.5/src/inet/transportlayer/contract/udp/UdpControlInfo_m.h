//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/transportlayer/contract/udp/UdpControlInfo.msg.
//

#ifndef __INET_UDPCONTROLINFO_M_H
#define __INET_UDPCONTROLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class UdpControlInfo;
class UdpBindCommand;
class UdpConnectCommand;
class UdpCloseCommand;
class UdpSocketClosedIndication;
class UdpDestroyCommand;
class UdpErrorIndication;
class UdpSetOptionCommand;
class UdpSetTimeToLiveCommand;
class UdpSetDscpCommand;
class UdpSetTosCommand;
class UdpSetBroadcastCommand;
class UdpSetMulticastInterfaceCommand;
class UdpSetMulticastLoopCommand;
class UdpSetReuseAddressCommand;
class UdpJoinMulticastGroupsCommand;
class UdpLeaveMulticastGroupsCommand;
class UdpBlockMulticastSourcesCommand;
class UdpUnblockMulticastSourcesCommand;
class UdpJoinMulticastSourcesCommand;
class UdpLeaveMulticastSourcesCommand;
class UdpSetMulticastSourceFilterCommand;

}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address


namespace inet {

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:20</tt> by opp_msgtool.
 * <pre>
 * //
 * // Udp command codes, sent by the application to ~Udp. These constants
 * // should be set as message kind on messages sent to the ~Udp entity.
 * //
 * // \@see ~UdpControlInfo, ~UdpStatusInd, ~Udp
 * //
 * enum UdpCommandCode
 * {
 *     UDP_C_DATA = 0;      // send()/sendTo(); see ~UDPSendCommand
 *     UDP_C_BIND = 1;      // bind(); see ~UdpBindCommand
 *     UDP_C_CONNECT = 2;   // connect(); see ~UdpConnectCommand
 *     UDP_C_SETOPTION = 3; // setsockopt(); see ~UdpSetTimeToLiveCommand,...
 *     UDP_C_CLOSE = 4;     // close(); see ~UdpCloseCommand
 *     UDP_C_DESTROY = 5;   // destroy(); see ~UdpDestroyCommand
 * }
 * </pre>
 */
enum UdpCommandCode {
    UDP_C_DATA = 0,
    UDP_C_BIND = 1,
    UDP_C_CONNECT = 2,
    UDP_C_SETOPTION = 3,
    UDP_C_CLOSE = 4,
    UDP_C_DESTROY = 5
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpCommandCode& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpCommandCode& e) { int n; b->unpack(n); e = static_cast<UdpCommandCode>(n); }

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:30</tt> by opp_msgtool.
 * <pre>
 * enum UdpSetOptionSubcode
 * {
 *     UDP_C_SETOPTION_TTL = 1;
 *     UDP_C_SETOPTION_DSCP = 2;
 *     UDP_C_SETOPTION_TOS = 3;
 *     UDP_C_SETOPTION_BROADCAST = 4;
 *     UDP_C_SETOPTION_MCAST_IFACE = 5;
 *     UDP_C_SETOPTION_MCAST_LOOP = 6;
 *     UDP_C_SETOPTION_REUSEADDR = 7;
 *     UDP_C_SETOPTION_JOIN_MCAST_GRP = 8;
 *     UDP_C_SETOPTION_LEAVE_MCAST_GRP = 9;
 *     UDP_C_SETOPTION_JOIN_MCAST_SRC = 10;
 *     UDP_C_SETOPTION_BLOCK_MCAST_SRC = 11;
 *     UDP_C_SETOPTION_UNBLOCK_MCAST_SRC = 12;
 *     UDP_C_SETOPTION_LEAVE_MCAST_SRC = 13;
 *     UDP_C_SETOPTION_SET_MCAST_SRC_FILTER = 14;
 * }
 * </pre>
 */
enum UdpSetOptionSubcode {
    UDP_C_SETOPTION_TTL = 1,
    UDP_C_SETOPTION_DSCP = 2,
    UDP_C_SETOPTION_TOS = 3,
    UDP_C_SETOPTION_BROADCAST = 4,
    UDP_C_SETOPTION_MCAST_IFACE = 5,
    UDP_C_SETOPTION_MCAST_LOOP = 6,
    UDP_C_SETOPTION_REUSEADDR = 7,
    UDP_C_SETOPTION_JOIN_MCAST_GRP = 8,
    UDP_C_SETOPTION_LEAVE_MCAST_GRP = 9,
    UDP_C_SETOPTION_JOIN_MCAST_SRC = 10,
    UDP_C_SETOPTION_BLOCK_MCAST_SRC = 11,
    UDP_C_SETOPTION_UNBLOCK_MCAST_SRC = 12,
    UDP_C_SETOPTION_LEAVE_MCAST_SRC = 13,
    UDP_C_SETOPTION_SET_MCAST_SRC_FILTER = 14
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetOptionSubcode& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetOptionSubcode& e) { int n; b->unpack(n); e = static_cast<UdpSetOptionSubcode>(n); }

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:54</tt> by opp_msgtool.
 * <pre>
 * //
 * // Udp indications, sent by ~Udp to the application. ~Udp will set these
 * // constants as message kind on messages it sends to the application.
 * //
 * // \@see ~UdpControlInfo, ~UdpCommandCode, ~Udp
 * //
 * enum UdpStatusInd
 * {
 *     UDP_I_DATA = 0;  // ~Udp attaches ~UDPIndication to received data packet
 *     UDP_I_ERROR = 1;
 *     UDP_I_SOCKET_CLOSED = 2;
 * }
 * </pre>
 */
enum UdpStatusInd {
    UDP_I_DATA = 0,
    UDP_I_ERROR = 1,
    UDP_I_SOCKET_CLOSED = 2
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpStatusInd& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpStatusInd& e) { int n; b->unpack(n); e = static_cast<UdpStatusInd>(n); }

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:67</tt> by opp_msgtool.
 * <pre>
 * //
 * // Base class for UDP control info classes. The most convenient way to handle
 * // ~Udp is the UdpSocket class, which hides control info from you.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpControlInfo extends cObject
 * {
 * }
 * </pre>
 */
class INET_API UdpControlInfo : public ::omnetpp::cObject
{
  protected:

  private:
    void copy(const UdpControlInfo& other);

  protected:
    bool operator==(const UdpControlInfo&) = delete;

  public:
    UdpControlInfo();
    UdpControlInfo(const UdpControlInfo& other);
    virtual ~UdpControlInfo();
    UdpControlInfo& operator=(const UdpControlInfo& other);
    virtual UdpControlInfo *dup() const override {return new UdpControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:81</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for binding an UDP socket. To create and bind a socket,
 * // send a message to the ~Udp module with kind=UDP_C_BIND and an
 * // ~UdpBindCommand attached.
 * //
 * // Both the address and the port may be left unset. If the port is
 * // unset, ~Udp will assign an ephemeral port.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpBindCommand extends UdpControlInfo
 * {
 *     L3Address localAddr;
 *     int localPort = -1;
 * }
 * </pre>
 */
class INET_API UdpBindCommand : public ::inet::UdpControlInfo
{
  protected:
    L3Address localAddr;
    int localPort = -1;

  private:
    void copy(const UdpBindCommand& other);

  protected:
    bool operator==(const UdpBindCommand&) = delete;

  public:
    UdpBindCommand();
    UdpBindCommand(const UdpBindCommand& other);
    virtual ~UdpBindCommand();
    UdpBindCommand& operator=(const UdpBindCommand& other);
    virtual UdpBindCommand *dup() const override {return new UdpBindCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getLocalAddr() const;
    virtual L3Address& getLocalAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpBindCommand*>(this)->getLocalAddr());}
    virtual void setLocalAddr(const L3Address& localAddr);

    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpBindCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpBindCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:97</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for connecting an UDP socket. To connect a socket,
 * // send a message to the ~Udp module with kind=UDP_C_CONNECT and an
 * // ~UdpConnectCommand attached. If the socket does not exist,
 * // it will be created.
 * //
 * // Both the address and the port must be filled in.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpConnectCommand extends UdpControlInfo
 * {
 *     L3Address remoteAddr;
 *     int remotePort = -1;
 * }
 * 
 * //
 * // Control info for sending data via UDP. To send a packet, send it to
 * // the ~Udp module with kind=UDP_C_SEND and an ~UDPSendCommand attached.
 * //
 * // UDP_C_SEND/~UDPSendCommand models both the Unix send() and sendto() calls.
 * // If the socket is connected, tags not required, or destAddr/destPort may be left blank (send()),
 * // otherwise it must contain the destination for the packet (sendto()).
 * //
 * // \@see ~UdpCommandCode, ~PortsReq, ~L3AddressReq, ~InterfaceReq
 * //
 * </pre>
 */
class INET_API UdpConnectCommand : public ::inet::UdpControlInfo
{
  protected:
    L3Address remoteAddr;
    int remotePort = -1;

  private:
    void copy(const UdpConnectCommand& other);

  protected:
    bool operator==(const UdpConnectCommand&) = delete;

  public:
    UdpConnectCommand();
    UdpConnectCommand(const UdpConnectCommand& other);
    virtual ~UdpConnectCommand();
    UdpConnectCommand& operator=(const UdpConnectCommand& other);
    virtual UdpConnectCommand *dup() const override {return new UdpConnectCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpConnectCommand*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);

    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpConnectCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpConnectCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:121</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for closing an UDP socket. To close a socket, send a message
 * // to the ~Udp module with kind=UDP_C_CLOSE and an ~UdpCloseCommand attached.
 * // The Udp module will send an ~UdpSocketClosedIndication answer.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpCloseCommand extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpCloseCommand : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpCloseCommand& other);

  protected:
    bool operator==(const UdpCloseCommand&) = delete;

  public:
    UdpCloseCommand();
    UdpCloseCommand(const UdpCloseCommand& other);
    virtual ~UdpCloseCommand();
    UdpCloseCommand& operator=(const UdpCloseCommand& other);
    virtual UdpCloseCommand *dup() const override {return new UdpCloseCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpCloseCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpCloseCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:131</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for inform app about an UDP socket closed.
 * // This is answer to an ~UdpCloseCommand.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSocketClosedIndication extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpSocketClosedIndication : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpSocketClosedIndication& other);

  protected:
    bool operator==(const UdpSocketClosedIndication&) = delete;

  public:
    UdpSocketClosedIndication();
    UdpSocketClosedIndication(const UdpSocketClosedIndication& other);
    virtual ~UdpSocketClosedIndication();
    UdpSocketClosedIndication& operator=(const UdpSocketClosedIndication& other);
    virtual UdpSocketClosedIndication *dup() const override {return new UdpSocketClosedIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSocketClosedIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSocketClosedIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:141</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for destroying an UDP socket. To destroy a socket, send a message
 * // to the ~Udp module with kind=UDP_C_DESTROY and an ~UdpDestroyCommand attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpDestroyCommand extends UdpControlInfo
 * {
 * }
 * 
 * //
 * // Control info that is attached to received data packets, sent up from the
 * // ~Udp module to the application with UDP_I_DATA as message kind.
 * //
 * // \@see ~UdpCommandCode, ~L3AddressInd, ~PortsInd
 * //
 * </pre>
 */
class INET_API UdpDestroyCommand : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpDestroyCommand& other);

  protected:
    bool operator==(const UdpDestroyCommand&) = delete;

  public:
    UdpDestroyCommand();
    UdpDestroyCommand(const UdpDestroyCommand& other);
    virtual ~UdpDestroyCommand();
    UdpDestroyCommand& operator=(const UdpDestroyCommand& other);
    virtual UdpDestroyCommand *dup() const override {return new UdpDestroyCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpDestroyCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpDestroyCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:159</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info that is sent up from the ~Udp module to the application with
 * // UDP_I_ERROR as message kind when ~Udp receives an Icmp error for a packet
 * // previously sent from the socket.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpErrorIndication extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpErrorIndication : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpErrorIndication& other);

  protected:
    bool operator==(const UdpErrorIndication&) = delete;

  public:
    UdpErrorIndication();
    UdpErrorIndication(const UdpErrorIndication& other);
    virtual ~UdpErrorIndication();
    UdpErrorIndication& operator=(const UdpErrorIndication& other);
    virtual UdpErrorIndication *dup() const override {return new UdpErrorIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpErrorIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpErrorIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:166</tt> by opp_msgtool.
 * <pre>
 * //
 * // Base class for UDP socket option control info classes.
 * //
 * class UdpSetOptionCommand extends UdpControlInfo
 * {
 *     UdpSetOptionSubcode optionCode = static_cast<UdpSetOptionSubcode>(-1);
 * }
 * </pre>
 */
class INET_API UdpSetOptionCommand : public ::inet::UdpControlInfo
{
  protected:
    UdpSetOptionSubcode optionCode = static_cast<UdpSetOptionSubcode>(-1);

  private:
    void copy(const UdpSetOptionCommand& other);

  protected:
    bool operator==(const UdpSetOptionCommand&) = delete;

  public:
    UdpSetOptionCommand();
    UdpSetOptionCommand(const UdpSetOptionCommand& other);
    virtual ~UdpSetOptionCommand();
    UdpSetOptionCommand& operator=(const UdpSetOptionCommand& other);
    virtual UdpSetOptionCommand *dup() const override {return new UdpSetOptionCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual UdpSetOptionSubcode getOptionCode() const;
    virtual void setOptionCode(UdpSetOptionSubcode optionCode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetOptionCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetOptionCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:179</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the Time To Live (a.k.a. Hop Limit) option on an
 * // UDP socket. This option will affect both multicast and unicast packets.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetTimeToLiveCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_TTL;
 *     int ttl;
 * }
 * </pre>
 */
class INET_API UdpSetTimeToLiveCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int ttl = 0;

  private:
    void copy(const UdpSetTimeToLiveCommand& other);

  protected:
    bool operator==(const UdpSetTimeToLiveCommand&) = delete;

  public:
    UdpSetTimeToLiveCommand();
    UdpSetTimeToLiveCommand(const UdpSetTimeToLiveCommand& other);
    virtual ~UdpSetTimeToLiveCommand();
    UdpSetTimeToLiveCommand& operator=(const UdpSetTimeToLiveCommand& other);
    virtual UdpSetTimeToLiveCommand *dup() const override {return new UdpSetTimeToLiveCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getTtl() const;
    virtual void setTtl(int ttl);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetTimeToLiveCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetTimeToLiveCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:194</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the DSCP (DiffServ Code Point)
 * // header field on outgoing Ipv4/Ipv6 packets sent from an Udp socket.
 * // This is a 6-bit field.
 * // To set the option, send a message to  the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetDscpCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_DSCP;
 *     short dscp;  // diffserv code point for Ipv4/Ipv6
 * }
 * </pre>
 */
class INET_API UdpSetDscpCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    short dscp = 0;

  private:
    void copy(const UdpSetDscpCommand& other);

  protected:
    bool operator==(const UdpSetDscpCommand&) = delete;

  public:
    UdpSetDscpCommand();
    UdpSetDscpCommand(const UdpSetDscpCommand& other);
    virtual ~UdpSetDscpCommand();
    UdpSetDscpCommand& operator=(const UdpSetDscpCommand& other);
    virtual UdpSetDscpCommand *dup() const override {return new UdpSetDscpCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual short getDscp() const;
    virtual void setDscp(short dscp);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetDscpCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetDscpCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:209</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the TOS (Type Of Service) / Traffic Class
 * // header field on outgoing Ipv4/Ipv6 packets sent from an Udp socket.
 * // This is a 8-bit field.
 * // To set the option, send a message to  the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetTosCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_TOS;
 *     short tos;  // type of service for Ipv4 / Traffic class for Ipv6
 * }
 * </pre>
 */
class INET_API UdpSetTosCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    short tos = 0;

  private:
    void copy(const UdpSetTosCommand& other);

  protected:
    bool operator==(const UdpSetTosCommand&) = delete;

  public:
    UdpSetTosCommand();
    UdpSetTosCommand(const UdpSetTosCommand& other);
    virtual ~UdpSetTosCommand();
    UdpSetTosCommand& operator=(const UdpSetTosCommand& other);
    virtual UdpSetTosCommand *dup() const override {return new UdpSetTosCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual short getTos() const;
    virtual void setTos(short tos);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetTosCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetTosCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:222</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the Broadcast option on an UDP socket.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetBroadcastCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_BROADCAST;
 *     bool broadcast;
 * }
 * </pre>
 */
class INET_API UdpSetBroadcastCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    bool broadcast = false;

  private:
    void copy(const UdpSetBroadcastCommand& other);

  protected:
    bool operator==(const UdpSetBroadcastCommand&) = delete;

  public:
    UdpSetBroadcastCommand();
    UdpSetBroadcastCommand(const UdpSetBroadcastCommand& other);
    virtual ~UdpSetBroadcastCommand();
    UdpSetBroadcastCommand& operator=(const UdpSetBroadcastCommand& other);
    virtual UdpSetBroadcastCommand *dup() const override {return new UdpSetBroadcastCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getBroadcast() const;
    virtual void setBroadcast(bool broadcast);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetBroadcastCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetBroadcastCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:235</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the multicast output interface for an UDP socket.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetMulticastInterfaceCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_MCAST_IFACE;
 *     int interfaceId;
 * }
 * </pre>
 */
class INET_API UdpSetMulticastInterfaceCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;

  private:
    void copy(const UdpSetMulticastInterfaceCommand& other);

  protected:
    bool operator==(const UdpSetMulticastInterfaceCommand&) = delete;

  public:
    UdpSetMulticastInterfaceCommand();
    UdpSetMulticastInterfaceCommand(const UdpSetMulticastInterfaceCommand& other);
    virtual ~UdpSetMulticastInterfaceCommand();
    UdpSetMulticastInterfaceCommand& operator=(const UdpSetMulticastInterfaceCommand& other);
    virtual UdpSetMulticastInterfaceCommand *dup() const override {return new UdpSetMulticastInterfaceCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetMulticastInterfaceCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetMulticastInterfaceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:250</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the multicast loop option for an UDP socket.
 * // When the option is true, a copy of the outgoing multicast packet
 * // is delivered locally via the loopback interface.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetMulticastLoopCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_MCAST_LOOP;
 *     bool loop;
 * }
 * </pre>
 */
class INET_API UdpSetMulticastLoopCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    bool loop = false;

  private:
    void copy(const UdpSetMulticastLoopCommand& other);

  protected:
    bool operator==(const UdpSetMulticastLoopCommand&) = delete;

  public:
    UdpSetMulticastLoopCommand();
    UdpSetMulticastLoopCommand(const UdpSetMulticastLoopCommand& other);
    virtual ~UdpSetMulticastLoopCommand();
    UdpSetMulticastLoopCommand& operator=(const UdpSetMulticastLoopCommand& other);
    virtual UdpSetMulticastLoopCommand *dup() const override {return new UdpSetMulticastLoopCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getLoop() const;
    virtual void setLoop(bool loop);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetMulticastLoopCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetMulticastLoopCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:265</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for setting the ReuseAddress option on an UDP socket.
 * // When the option is true, then the socket is allowed to bind to an already bound
 * // local address.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetReuseAddressCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_REUSEADDR;
 *     bool reuseAddress;
 * }
 * </pre>
 */
class INET_API UdpSetReuseAddressCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    bool reuseAddress = false;

  private:
    void copy(const UdpSetReuseAddressCommand& other);

  protected:
    bool operator==(const UdpSetReuseAddressCommand&) = delete;

  public:
    UdpSetReuseAddressCommand();
    UdpSetReuseAddressCommand(const UdpSetReuseAddressCommand& other);
    virtual ~UdpSetReuseAddressCommand();
    UdpSetReuseAddressCommand& operator=(const UdpSetReuseAddressCommand& other);
    virtual UdpSetReuseAddressCommand *dup() const override {return new UdpSetReuseAddressCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual bool getReuseAddress() const;
    virtual void setReuseAddress(bool reuseAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetReuseAddressCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetReuseAddressCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:282</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket join multicast groups.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // The address-interfaceId pairs are passed as two separate arrays.
 * // When there are less interfaceIds than multicast addresses,
 * // then -1 is assumed (meaning join on all interfaces).
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpJoinMulticastGroupsCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_JOIN_MCAST_GRP;
 *     L3Address multicastAddr[];
 *     int interfaceId[];
 * }
 * </pre>
 */
class INET_API UdpJoinMulticastGroupsCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    L3Address *multicastAddr = nullptr;
    size_t multicastAddr_arraysize = 0;
    int *interfaceId = nullptr;
    size_t interfaceId_arraysize = 0;

  private:
    void copy(const UdpJoinMulticastGroupsCommand& other);

  protected:
    bool operator==(const UdpJoinMulticastGroupsCommand&) = delete;

  public:
    UdpJoinMulticastGroupsCommand();
    UdpJoinMulticastGroupsCommand(const UdpJoinMulticastGroupsCommand& other);
    virtual ~UdpJoinMulticastGroupsCommand();
    UdpJoinMulticastGroupsCommand& operator=(const UdpJoinMulticastGroupsCommand& other);
    virtual UdpJoinMulticastGroupsCommand *dup() const override {return new UdpJoinMulticastGroupsCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setMulticastAddrArraySize(size_t size);
    virtual size_t getMulticastAddrArraySize() const;
    virtual const L3Address& getMulticastAddr(size_t k) const;
    virtual L3Address& getMulticastAddrForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpJoinMulticastGroupsCommand*>(this)->getMulticastAddr(k));}
    virtual void setMulticastAddr(size_t k, const L3Address& multicastAddr);
    virtual void insertMulticastAddr(size_t k, const L3Address& multicastAddr);
    [[deprecated]] void insertMulticastAddr(const L3Address& multicastAddr) {appendMulticastAddr(multicastAddr);}
    virtual void appendMulticastAddr(const L3Address& multicastAddr);
    virtual void eraseMulticastAddr(size_t k);

    virtual void setInterfaceIdArraySize(size_t size);
    virtual size_t getInterfaceIdArraySize() const;
    virtual int getInterfaceId(size_t k) const;
    virtual void setInterfaceId(size_t k, int interfaceId);
    virtual void insertInterfaceId(size_t k, int interfaceId);
    [[deprecated]] void insertInterfaceId(int interfaceId) {appendInterfaceId(interfaceId);}
    virtual void appendInterfaceId(int interfaceId);
    virtual void eraseInterfaceId(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpJoinMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpJoinMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:296</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket leave multicast groups.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpLeaveMulticastGroupsCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_LEAVE_MCAST_GRP;
 *     L3Address multicastAddr[];
 * }
 * </pre>
 */
class INET_API UdpLeaveMulticastGroupsCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    L3Address *multicastAddr = nullptr;
    size_t multicastAddr_arraysize = 0;

  private:
    void copy(const UdpLeaveMulticastGroupsCommand& other);

  protected:
    bool operator==(const UdpLeaveMulticastGroupsCommand&) = delete;

  public:
    UdpLeaveMulticastGroupsCommand();
    UdpLeaveMulticastGroupsCommand(const UdpLeaveMulticastGroupsCommand& other);
    virtual ~UdpLeaveMulticastGroupsCommand();
    UdpLeaveMulticastGroupsCommand& operator=(const UdpLeaveMulticastGroupsCommand& other);
    virtual UdpLeaveMulticastGroupsCommand *dup() const override {return new UdpLeaveMulticastGroupsCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setMulticastAddrArraySize(size_t size);
    virtual size_t getMulticastAddrArraySize() const;
    virtual const L3Address& getMulticastAddr(size_t k) const;
    virtual L3Address& getMulticastAddrForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpLeaveMulticastGroupsCommand*>(this)->getMulticastAddr(k));}
    virtual void setMulticastAddr(size_t k, const L3Address& multicastAddr);
    virtual void insertMulticastAddr(size_t k, const L3Address& multicastAddr);
    [[deprecated]] void insertMulticastAddr(const L3Address& multicastAddr) {appendMulticastAddr(multicastAddr);}
    virtual void appendMulticastAddr(const L3Address& multicastAddr);
    virtual void eraseMulticastAddr(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpLeaveMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpLeaveMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:307</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to block multicast traffic from
 * // specific sources after joining a multicast group.
 * //
 * // see IP_BLOCK_SOURCE socket option
 * class UdpBlockMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_BLOCK_MCAST_SRC;
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpBlockMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpBlockMulticastSourcesCommand& other);

  protected:
    bool operator==(const UdpBlockMulticastSourcesCommand&) = delete;

  public:
    UdpBlockMulticastSourcesCommand();
    UdpBlockMulticastSourcesCommand(const UdpBlockMulticastSourcesCommand& other);
    virtual ~UdpBlockMulticastSourcesCommand();
    UdpBlockMulticastSourcesCommand& operator=(const UdpBlockMulticastSourcesCommand& other);
    virtual UdpBlockMulticastSourcesCommand *dup() const override {return new UdpBlockMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);

    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpBlockMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);

    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpBlockMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    [[deprecated]] void insertSourceList(const L3Address& sourceList) {appendSourceList(sourceList);}
    virtual void appendSourceList(const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpBlockMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpBlockMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:320</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to permit multicast traffic from
 * // a previously blocked source.
 * //
 * // see IP_UNBLOCK_SOURCE socket option
 * class UdpUnblockMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_UNBLOCK_MCAST_SRC;
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpUnblockMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpUnblockMulticastSourcesCommand& other);

  protected:
    bool operator==(const UdpUnblockMulticastSourcesCommand&) = delete;

  public:
    UdpUnblockMulticastSourcesCommand();
    UdpUnblockMulticastSourcesCommand(const UdpUnblockMulticastSourcesCommand& other);
    virtual ~UdpUnblockMulticastSourcesCommand();
    UdpUnblockMulticastSourcesCommand& operator=(const UdpUnblockMulticastSourcesCommand& other);
    virtual UdpUnblockMulticastSourcesCommand *dup() const override {return new UdpUnblockMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);

    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpUnblockMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);

    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpUnblockMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    [[deprecated]] void insertSourceList(const L3Address& sourceList) {appendSourceList(sourceList);}
    virtual void appendSourceList(const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpUnblockMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpUnblockMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:333</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to join a multicast group
 * // only for the selected sources.
 * //
 * // see IP_ADD_SOURCE_MEMBERSHIP socket option
 * class UdpJoinMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_JOIN_MCAST_SRC;
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpJoinMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpJoinMulticastSourcesCommand& other);

  protected:
    bool operator==(const UdpJoinMulticastSourcesCommand&) = delete;

  public:
    UdpJoinMulticastSourcesCommand();
    UdpJoinMulticastSourcesCommand(const UdpJoinMulticastSourcesCommand& other);
    virtual ~UdpJoinMulticastSourcesCommand();
    UdpJoinMulticastSourcesCommand& operator=(const UdpJoinMulticastSourcesCommand& other);
    virtual UdpJoinMulticastSourcesCommand *dup() const override {return new UdpJoinMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);

    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpJoinMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);

    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpJoinMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    [[deprecated]] void insertSourceList(const L3Address& sourceList) {appendSourceList(sourceList);}
    virtual void appendSourceList(const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpJoinMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpJoinMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:346</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to leave a multicast group
 * // for the selected sources.
 * //
 * // see IP_DROP_SOURCE_MEMBERSHIP socket option
 * class UdpLeaveMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_LEAVE_MCAST_SRC;
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpLeaveMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpLeaveMulticastSourcesCommand& other);

  protected:
    bool operator==(const UdpLeaveMulticastSourcesCommand&) = delete;

  public:
    UdpLeaveMulticastSourcesCommand();
    UdpLeaveMulticastSourcesCommand(const UdpLeaveMulticastSourcesCommand& other);
    virtual ~UdpLeaveMulticastSourcesCommand();
    UdpLeaveMulticastSourcesCommand& operator=(const UdpLeaveMulticastSourcesCommand& other);
    virtual UdpLeaveMulticastSourcesCommand *dup() const override {return new UdpLeaveMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);

    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpLeaveMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);

    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpLeaveMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    [[deprecated]] void insertSourceList(const L3Address& sourceList) {appendSourceList(sourceList);}
    virtual void appendSourceList(const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpLeaveMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpLeaveMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:353</tt> by opp_msgtool.
 * <pre>
 * enum UdpSourceFilterMode
 * {
 *     UDP_INCLUDE_MCAST_SOURCES = 1;
 *     UDP_EXCLUDE_MCAST_SOURCES = 2;
 * }
 * </pre>
 */
enum UdpSourceFilterMode {
    UDP_INCLUDE_MCAST_SOURCES = 1,
    UDP_EXCLUDE_MCAST_SOURCES = 2
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSourceFilterMode& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSourceFilterMode& e) { int n; b->unpack(n); e = static_cast<UdpSourceFilterMode>(n); }

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:363</tt> by opp_msgtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to specify the excluded/included
 * // sources for a multicast group.
 * //
 * // Unlike Block/Unblock/Join/LeaveMulticastSource commands, this method is
 * // not incremental.
 * //
 * class UdpSetMulticastSourceFilterCommand extends UdpSetOptionCommand
 * {
 *     optionCode = UDP_C_SETOPTION_SET_MCAST_SRC_FILTER;
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     UdpSourceFilterMode filterMode;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpSetMulticastSourceFilterCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    UdpSourceFilterMode filterMode = static_cast<inet::UdpSourceFilterMode>(-1);
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpSetMulticastSourceFilterCommand& other);

  protected:
    bool operator==(const UdpSetMulticastSourceFilterCommand&) = delete;

  public:
    UdpSetMulticastSourceFilterCommand();
    UdpSetMulticastSourceFilterCommand(const UdpSetMulticastSourceFilterCommand& other);
    virtual ~UdpSetMulticastSourceFilterCommand();
    UdpSetMulticastSourceFilterCommand& operator=(const UdpSetMulticastSourceFilterCommand& other);
    virtual UdpSetMulticastSourceFilterCommand *dup() const override {return new UdpSetMulticastSourceFilterCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);

    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpSetMulticastSourceFilterCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);

    virtual UdpSourceFilterMode getFilterMode() const;
    virtual void setFilterMode(UdpSourceFilterMode filterMode);

    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpSetMulticastSourceFilterCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    [[deprecated]] void insertSourceList(const L3Address& sourceList) {appendSourceList(sourceList);}
    virtual void appendSourceList(const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetMulticastSourceFilterCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetMulticastSourceFilterCommand& obj) {obj.parsimUnpack(b);}


}  // namespace inet


namespace omnetpp {

template<> inline inet::UdpControlInfo *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpControlInfo*>(ptr.get<cObject>()); }
template<> inline inet::UdpBindCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpBindCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpConnectCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpConnectCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpCloseCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpCloseCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSocketClosedIndication *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSocketClosedIndication*>(ptr.get<cObject>()); }
template<> inline inet::UdpDestroyCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpDestroyCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpErrorIndication *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpErrorIndication*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetOptionCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetOptionCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetTimeToLiveCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetTimeToLiveCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetDscpCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetDscpCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetTosCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetTosCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetBroadcastCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetBroadcastCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetMulticastInterfaceCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetMulticastInterfaceCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetMulticastLoopCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetMulticastLoopCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetReuseAddressCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetReuseAddressCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpJoinMulticastGroupsCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpJoinMulticastGroupsCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpLeaveMulticastGroupsCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpLeaveMulticastGroupsCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpBlockMulticastSourcesCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpBlockMulticastSourcesCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpUnblockMulticastSourcesCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpUnblockMulticastSourcesCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpJoinMulticastSourcesCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpJoinMulticastSourcesCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpLeaveMulticastSourcesCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpLeaveMulticastSourcesCommand*>(ptr.get<cObject>()); }
template<> inline inet::UdpSetMulticastSourceFilterCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::UdpSetMulticastSourceFilterCommand*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_UDPCONTROLINFO_M_H


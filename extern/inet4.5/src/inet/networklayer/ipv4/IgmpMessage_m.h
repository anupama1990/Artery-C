//
// Generated file, do not edit! Created by opp_msgtool 6.0 from inet/networklayer/ipv4/IgmpMessage.msg.
//

#ifndef __INET_IGMPMESSAGE_M_H
#define __INET_IGMPMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class IgmpMessage;
class IgmpQuery;
class Igmpv1Query;
class Igmpv1Report;
class Igmpv2Query;
class Igmpv2Report;
class Igmpv2Leave;
class Igmpv3Query;
class GroupRecord;
class Igmpv3Report;

}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode


namespace inet {

/**
 * Enum generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:16</tt> by opp_msgtool.
 * <pre>
 * enum IgmpTimerKind
 * {
 *     IGMP_QUERY_TIMER = 1001;
 *     IGMP_HOSTGROUP_TIMER = 1002;
 *     IGMP_LEAVE_TIMER = 1003;
 *     IGMP_REXMT_TIMER = 1004;
 * }
 * </pre>
 */
enum IgmpTimerKind {
    IGMP_QUERY_TIMER = 1001,
    IGMP_HOSTGROUP_TIMER = 1002,
    IGMP_LEAVE_TIMER = 1003,
    IGMP_REXMT_TIMER = 1004
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IgmpTimerKind& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IgmpTimerKind& e) { int n; b->unpack(n); e = static_cast<IgmpTimerKind>(n); }

/**
 * Enum generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:24</tt> by opp_msgtool.
 * <pre>
 * enum IgmpType
 * {
 *     IGMP_MEMBERSHIP_QUERY = 0x11;
 *     IGMPV1_MEMBERSHIP_REPORT = 0x12;
 *     IGMPV2_MEMBERSHIP_REPORT = 0x16;
 *     IGMPV2_LEAVE_GROUP = 0x17;
 *     IGMPV3_MEMBERSHIP_REPORT = 0x22;
 * }
 * </pre>
 */
enum IgmpType {
    IGMP_MEMBERSHIP_QUERY = 0x11,
    IGMPV1_MEMBERSHIP_REPORT = 0x12,
    IGMPV2_MEMBERSHIP_REPORT = 0x16,
    IGMPV2_LEAVE_GROUP = 0x17,
    IGMPV3_MEMBERSHIP_REPORT = 0x22
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IgmpType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IgmpType& e) { int n; b->unpack(n); e = static_cast<IgmpType>(n); }

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:33</tt> by opp_msgtool.
 * <pre>
 * class IgmpMessage extends FieldsChunk
 * {
 *     IgmpType type;         // 1 byte
 *     uint16_t crc = 0;    // 2 bytes, The checksum is the 16-bit one's complement of the one's complement sum of the whole IGMP message (the entire IP payload).
 *     CrcMode crcMode = CRC_MODE_UNDEFINED;  // 0 bytes, inet only
 * }
 * </pre>
 */
class INET_API IgmpMessage : public ::inet::FieldsChunk
{
  protected:
    IgmpType type = static_cast<inet::IgmpType>(-1);
    uint16_t crc = 0;
    CrcMode crcMode = CRC_MODE_UNDEFINED;

  private:
    void copy(const IgmpMessage& other);

  protected:
    bool operator==(const IgmpMessage&) = delete;

  public:
    IgmpMessage();
    IgmpMessage(const IgmpMessage& other);
    virtual ~IgmpMessage();
    IgmpMessage& operator=(const IgmpMessage& other);
    virtual IgmpMessage *dup() const override {return new IgmpMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual IgmpType getType() const;
    virtual void setType(IgmpType type);

    virtual uint16_t getCrc() const;
    virtual void setCrc(uint16_t crc);

    virtual CrcMode getCrcMode() const;
    virtual void setCrcMode(CrcMode crcMode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IgmpMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IgmpMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:40</tt> by opp_msgtool.
 * <pre>
 * class IgmpQuery extends IgmpMessage
 * {
 *     type = IGMP_MEMBERSHIP_QUERY;
 *     Ipv4Address groupAddress;
 * }
 * </pre>
 */
class INET_API IgmpQuery : public ::inet::IgmpMessage
{
  protected:
    Ipv4Address groupAddress;

  private:
    void copy(const IgmpQuery& other);

  protected:
    bool operator==(const IgmpQuery&) = delete;

  public:
    IgmpQuery();
    IgmpQuery(const IgmpQuery& other);
    virtual ~IgmpQuery();
    IgmpQuery& operator=(const IgmpQuery& other);
    virtual IgmpQuery *dup() const override {return new IgmpQuery(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<IgmpQuery*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IgmpQuery& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IgmpQuery& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:46</tt> by opp_msgtool.
 * <pre>
 * class Igmpv1Query extends IgmpQuery
 * {
 *     chunkLength = B(8);
 *     uint8_t unused = 0;
 * }
 * </pre>
 */
class INET_API Igmpv1Query : public ::inet::IgmpQuery
{
  protected:
    uint8_t unused = 0;

  private:
    void copy(const Igmpv1Query& other);

  protected:
    bool operator==(const Igmpv1Query&) = delete;

  public:
    Igmpv1Query();
    Igmpv1Query(const Igmpv1Query& other);
    virtual ~Igmpv1Query();
    Igmpv1Query& operator=(const Igmpv1Query& other);
    virtual Igmpv1Query *dup() const override {return new Igmpv1Query(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getUnused() const;
    virtual void setUnused(uint8_t unused);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv1Query& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv1Query& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:52</tt> by opp_msgtool.
 * <pre>
 * class Igmpv1Report extends IgmpMessage
 * {
 *     chunkLength = B(8);
 *     type = IGMPV1_MEMBERSHIP_REPORT;
 *     uint8_t unused = 0;
 *     Ipv4Address groupAddress;
 * }
 * </pre>
 */
class INET_API Igmpv1Report : public ::inet::IgmpMessage
{
  protected:
    uint8_t unused = 0;
    Ipv4Address groupAddress;

  private:
    void copy(const Igmpv1Report& other);

  protected:
    bool operator==(const Igmpv1Report&) = delete;

  public:
    Igmpv1Report();
    Igmpv1Report(const Igmpv1Report& other);
    virtual ~Igmpv1Report();
    Igmpv1Report& operator=(const Igmpv1Report& other);
    virtual Igmpv1Report *dup() const override {return new Igmpv1Report(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getUnused() const;
    virtual void setUnused(uint8_t unused);

    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Igmpv1Report*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv1Report& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv1Report& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:60</tt> by opp_msgtool.
 * <pre>
 * class Igmpv2Query extends IgmpQuery      //FIXME Igmpv1Query and Igmpv2Query differs only value of code field.
 * {
 *     chunkLength = B(8);
 *     uint8_t maxRespTimeCode;      // stored in `code` in units of 1/10 second, 0.1-25.5s
 * }
 * </pre>
 */
class INET_API Igmpv2Query : public ::inet::IgmpQuery
{
  protected:
    uint8_t maxRespTimeCode = 0;

  private:
    void copy(const Igmpv2Query& other);

  protected:
    bool operator==(const Igmpv2Query&) = delete;

  public:
    Igmpv2Query();
    Igmpv2Query(const Igmpv2Query& other);
    virtual ~Igmpv2Query();
    Igmpv2Query& operator=(const Igmpv2Query& other);
    virtual Igmpv2Query *dup() const override {return new Igmpv2Query(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getMaxRespTimeCode() const;
    virtual void setMaxRespTimeCode(uint8_t maxRespTimeCode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv2Query& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv2Query& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:66</tt> by opp_msgtool.
 * <pre>
 * class Igmpv2Report extends IgmpMessage
 * {
 *     chunkLength = B(8);
 *     type = IGMPV2_MEMBERSHIP_REPORT;
 *     uint8_t maxRespTime = 0;
 *     Ipv4Address groupAddress;
 * }
 * </pre>
 */
class INET_API Igmpv2Report : public ::inet::IgmpMessage
{
  protected:
    uint8_t maxRespTime = 0;
    Ipv4Address groupAddress;

  private:
    void copy(const Igmpv2Report& other);

  protected:
    bool operator==(const Igmpv2Report&) = delete;

  public:
    Igmpv2Report();
    Igmpv2Report(const Igmpv2Report& other);
    virtual ~Igmpv2Report();
    Igmpv2Report& operator=(const Igmpv2Report& other);
    virtual Igmpv2Report *dup() const override {return new Igmpv2Report(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getMaxRespTime() const;
    virtual void setMaxRespTime(uint8_t maxRespTime);

    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Igmpv2Report*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv2Report& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv2Report& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:74</tt> by opp_msgtool.
 * <pre>
 * class Igmpv2Leave extends IgmpMessage
 * {
 *     chunkLength = B(8);
 *     type = IGMPV2_LEAVE_GROUP;
 *     uint8_t maxRespTime = 0;
 *     Ipv4Address groupAddress;
 * }
 * </pre>
 */
class INET_API Igmpv2Leave : public ::inet::IgmpMessage
{
  protected:
    uint8_t maxRespTime = 0;
    Ipv4Address groupAddress;

  private:
    void copy(const Igmpv2Leave& other);

  protected:
    bool operator==(const Igmpv2Leave&) = delete;

  public:
    Igmpv2Leave();
    Igmpv2Leave(const Igmpv2Leave& other);
    virtual ~Igmpv2Leave();
    Igmpv2Leave& operator=(const Igmpv2Leave& other);
    virtual Igmpv2Leave *dup() const override {return new Igmpv2Leave(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getMaxRespTime() const;
    virtual void setMaxRespTime(uint8_t maxRespTime);

    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<Igmpv2Leave*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv2Leave& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv2Leave& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:89</tt> by opp_msgtool.
 * <pre>
 * //
 * // Igmpv3Query extends Igmpv2Query, because
 * // Igmpv2 routers must accept Igmpv3Query packets.
 * //
 * // Note: in Igmpv3Query the maxResponseTime field is
 * // renamed to maxResponseCode and it is interpreted
 * // differently than in Igmpv2.
 * class Igmpv3Query extends Igmpv2Query
 * {
 *     chunkLength = B(12);    // 12 + sourceListArraySize * 4
 *     // maxRespTime stored in `code` in units of 1/10 second
 *     //     0-127: 0-12.7s
 *     //   128-255: 1eeemmmm : (mant | 0x10) << (exp + 3)
 *     uint8_t resv = 0;    // 4 bit
 *     bool suppressRouterProc;    // 1 bit, S flag
 *     uint8_t robustnessVariable;    // 3 bit, QRV
 *     uint8_t queryIntervalCode;    // 8 bit, QQIC, in seconds, format similar to macRespTime (0nnnnnnn or 1eeemmmm)
 *     Ipv4AddressVector sourceList;    // 16 + n*32 bit
 * }
 * </pre>
 */
class INET_API Igmpv3Query : public ::inet::Igmpv2Query
{
  protected:
    uint8_t resv = 0;
    bool suppressRouterProc = false;
    uint8_t robustnessVariable = 0;
    uint8_t queryIntervalCode = 0;
    Ipv4AddressVector sourceList;

  private:
    void copy(const Igmpv3Query& other);

  protected:
    bool operator==(const Igmpv3Query&) = delete;

  public:
    Igmpv3Query();
    Igmpv3Query(const Igmpv3Query& other);
    virtual ~Igmpv3Query();
    Igmpv3Query& operator=(const Igmpv3Query& other);
    virtual Igmpv3Query *dup() const override {return new Igmpv3Query(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getResv() const;
    virtual void setResv(uint8_t resv);

    virtual bool getSuppressRouterProc() const;
    virtual void setSuppressRouterProc(bool suppressRouterProc);

    virtual uint8_t getRobustnessVariable() const;
    virtual void setRobustnessVariable(uint8_t robustnessVariable);

    virtual uint8_t getQueryIntervalCode() const;
    virtual void setQueryIntervalCode(uint8_t queryIntervalCode);

    virtual const Ipv4AddressVector& getSourceList() const;
    virtual Ipv4AddressVector& getSourceListForUpdate() { handleChange();return const_cast<Ipv4AddressVector&>(const_cast<Igmpv3Query*>(this)->getSourceList());}
    virtual void setSourceList(const Ipv4AddressVector& sourceList);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv3Query& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv3Query& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:102</tt> by opp_msgtool.
 * <pre>
 * enum GroupRecordType
 * {
 *     MODE_IS_INCLUDE = 1;
 *     MODE_IS_EXCLUDE = 2;
 *     CHANGE_TO_INCLUDE_MODE = 3;
 *     CHANGE_TO_EXCLUDE_MODE = 4;
 *     ALLOW_NEW_SOURCES = 5;
 *     BLOCK_OLD_SOURCE = 6;
 * }
 * </pre>
 */
enum GroupRecordType {
    MODE_IS_INCLUDE = 1,
    MODE_IS_EXCLUDE = 2,
    CHANGE_TO_INCLUDE_MODE = 3,
    CHANGE_TO_EXCLUDE_MODE = 4,
    ALLOW_NEW_SOURCES = 5,
    BLOCK_OLD_SOURCE = 6
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GroupRecordType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GroupRecordType& e) { int n; b->unpack(n); e = static_cast<GroupRecordType>(n); }

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:112</tt> by opp_msgtool.
 * <pre>
 * class GroupRecord
 * {
 *     \@packetData;
 *     int recordType \@enum(GroupRecordType);
 *     Ipv4Address groupAddress;
 *     Ipv4AddressVector sourceList;
 *     uint32_t auxData[];
 * }
 * </pre>
 */
class INET_API GroupRecord
{
  protected:
    int recordType = 0;
    Ipv4Address groupAddress;
    Ipv4AddressVector sourceList;
    uint32_t *auxData = nullptr;
    size_t auxData_arraysize = 0;

  private:
    void copy(const GroupRecord& other);

  protected:
    bool operator==(const GroupRecord&) = delete;

  public:
    GroupRecord();
    GroupRecord(const GroupRecord& other);
    virtual ~GroupRecord();
    GroupRecord& operator=(const GroupRecord& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    virtual int getRecordType() const;
    virtual void setRecordType(int recordType);

    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { return const_cast<Ipv4Address&>(const_cast<GroupRecord*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);

    virtual const Ipv4AddressVector& getSourceList() const;
    virtual Ipv4AddressVector& getSourceListForUpdate() { return const_cast<Ipv4AddressVector&>(const_cast<GroupRecord*>(this)->getSourceList());}
    virtual void setSourceList(const Ipv4AddressVector& sourceList);

    virtual void setAuxDataArraySize(size_t size);
    virtual size_t getAuxDataArraySize() const;
    virtual uint32_t getAuxData(size_t k) const;
    virtual void setAuxData(size_t k, uint32_t auxData);
    virtual void insertAuxData(size_t k, uint32_t auxData);
    [[deprecated]] void insertAuxData(uint32_t auxData) {appendAuxData(auxData);}
    virtual void appendAuxData(uint32_t auxData);
    virtual void eraseAuxData(size_t k);
};

/**
 * Class generated from <tt>inet/networklayer/ipv4/IgmpMessage.msg:121</tt> by opp_msgtool.
 * <pre>
 * class Igmpv3Report extends IgmpMessage
 * {
 *     type = IGMPV3_MEMBERSHIP_REPORT;
 *     uint8_t resv1 = 0;
 *     uint16_t resv2 = 0;
 *     GroupRecord groupRecord[];
 * }
 * </pre>
 */
class INET_API Igmpv3Report : public ::inet::IgmpMessage
{
  protected:
    uint8_t resv1 = 0;
    uint16_t resv2 = 0;
    GroupRecord *groupRecord = nullptr;
    size_t groupRecord_arraysize = 0;

  private:
    void copy(const Igmpv3Report& other);

  protected:
    bool operator==(const Igmpv3Report&) = delete;

  public:
    Igmpv3Report();
    Igmpv3Report(const Igmpv3Report& other);
    virtual ~Igmpv3Report();
    Igmpv3Report& operator=(const Igmpv3Report& other);
    virtual Igmpv3Report *dup() const override {return new Igmpv3Report(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getResv1() const;
    virtual void setResv1(uint8_t resv1);

    virtual uint16_t getResv2() const;
    virtual void setResv2(uint16_t resv2);

    virtual void setGroupRecordArraySize(size_t size);
    virtual size_t getGroupRecordArraySize() const;
    virtual const GroupRecord& getGroupRecord(size_t k) const;
    virtual GroupRecord& getGroupRecordForUpdate(size_t k) { handleChange();return const_cast<GroupRecord&>(const_cast<Igmpv3Report*>(this)->getGroupRecord(k));}
    virtual void setGroupRecord(size_t k, const GroupRecord& groupRecord);
    virtual void insertGroupRecord(size_t k, const GroupRecord& groupRecord);
    [[deprecated]] void insertGroupRecord(const GroupRecord& groupRecord) {appendGroupRecord(groupRecord);}
    virtual void appendGroupRecord(const GroupRecord& groupRecord);
    virtual void eraseGroupRecord(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Igmpv3Report& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Igmpv3Report& obj) {obj.parsimUnpack(b);}


}  // namespace inet


namespace omnetpp {

template<> inline inet::IgmpMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::IgmpMessage*>(ptr.get<cObject>()); }
template<> inline inet::IgmpQuery *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::IgmpQuery*>(ptr.get<cObject>()); }
template<> inline inet::Igmpv1Query *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv1Query*>(ptr.get<cObject>()); }
template<> inline inet::Igmpv1Report *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv1Report*>(ptr.get<cObject>()); }
template<> inline inet::Igmpv2Query *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv2Query*>(ptr.get<cObject>()); }
template<> inline inet::Igmpv2Report *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv2Report*>(ptr.get<cObject>()); }
template<> inline inet::Igmpv2Leave *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv2Leave*>(ptr.get<cObject>()); }
template<> inline inet::Igmpv3Query *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv3Query*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::GroupRecord *p) {if (auto obj = as_cObject(p)) return any_ptr(obj); else return any_ptr(p);}
template<> inline inet::GroupRecord *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::GroupRecord>(); }
template<> inline inet::Igmpv3Report *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::Igmpv3Report*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_IGMPMESSAGE_M_H

